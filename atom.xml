<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>光</title>
  
  <subtitle>Life sucks, but you&#39;re gonna love it.</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-17T21:12:07.867Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chenxi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/10/17/test/"/>
    <id>http://yoursite.com/2020/10/17/test/</id>
    <published>2020-10-17T21:12:07.000Z</published>
    <updated>2020-10-17T21:12:07.867Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Paper Reading | Deep Residual Learning for Image Recognition</title>
    <link href="http://yoursite.com/2020/07/24/Paper-Reading-Deep-Residual-Learning-for-Image-Recognition/"/>
    <id>http://yoursite.com/2020/07/24/Paper-Reading-Deep-Residual-Learning-for-Image-Recognition/</id>
    <published>2020-07-24T16:18:53.000Z</published>
    <updated>2020-09-24T19:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这部分我们来看看这个经典结构ResNet首先被提出的文章。</p><ul><li>论文链接：<a href="https://arxiv.org/pdf/1512.03385.pdf">https://arxiv.org/pdf/1512.03385.pdf</a></li></ul><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>深度神经网络现在变得越来越难训练了。我们呈现了一种残差网络的框架来解决这个问题。我们重新搭建了网络模型，利用layer的input作为参考，学习残差方程，而不是直接学习没有参考的方程。</p><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>深度卷积神经网络在图片分类上带来了很大的突破。深度神经网络综合了从低到高的feature和端到端分类器，以及可以通过扩大训练层数而增加的feature的个数。近期的神经网络展现出来的网络结构的深度有着至关重要的作用，并且在ImageNet分类上，分类效果好的神经网络的层数都是在16-30之间。有很多其他的视觉方面的任务同样也受益于深度的网络结构。</p><p>那么急于网络深度的重要性，我们不禁要问：训练更好的神经网络真得就如同叠加积木一样简单吗？一个摆在这个问题之前的障碍是梯度爆炸和梯度消失的问题，但是梯度爆炸和小时大部分可以被BN来解决。</p><p>【这里应该是说，再深的神经网络，如果出现了梯度消失的问题，我们大可以用归一化输入和归一化每一层的feature来解决。】</p><p>当更多层的神经网络开始收敛的时候，一个网络退化的问题就暴露了：随着网络深度的增加，准确率开始趋于饱和然后开始急速下降。但这种退化并不是由于过拟合造成的，添加更多的层数不仅会使测试的准确率降低，训练的准确率也会降低。</p><p>【这里举了一个例子，是一个20层网络和一个56层网络的例子，通过增加神经网络的层数（深度）我们得到的网络分类效果并没有变得很好，而是训练和测试准确率变得更差了，所以不是简单的过拟合的问题。】</p><p>更深度的神经网络在训练数据集上的效果退化说明，并不是所有的系统都很好优化。让我们来考虑一个浅层的结构和一个在这个浅层结构的基础上增加量更多层的结构。如果我们新添加的这些层只是做简单的对应变化，也就是新添加的几层网络什么都不做，只是单纯的复制浅层网络的输出，那么我的这个深层的网络怎么着误差也应该和浅层网络的误差一样，那如果后面新添加的几层学到了更多的特征，得到的结果应该比浅层网络得到的结果更好才对。但之前的实验显示，新增加的几层并不能很好的体现这个理论。</p><p>在这篇文章里，我们利用深度残差网络解决了这个退化的问题。我们这里利用残差map来代替利用几个叠加的layer拟合出来一个mapping的方法。直观来讲，如果我们将理想情况下的mapping方程记做$\mathcal H(x)$, 现在我们对非线性叠加层定义一个新的map $\mathcal F(\bf x) := \mathcal H(\bf x) - x$, 这样一来之前的map就变成了 $\mathcal F(\bf x) + \bf x$ 我们现在的假设是，优化得到残差mapping比得到之前的mapping更加容易。在极端的角度上来讲，如果identity mapping是最优解，那么得到残差mapping的0比得到identity mapping更加容易。</p><p> $\mathcal F(\bf x) + \bf x$ 的结构就通过短接得到。短接的意思就是跳过一层或多层，在我们的这个方法里，短接的直接是通过identity mapping，然后得到的结果直接连在之前正常输出的结果上。</p><p><img src="../images/Screen%20Shot%202020-07-24%20at%2021.54.23.png" alt="Screen Shot 2020-07-24 at 21.54.23"></p><p>我们在ImageNet数据上面证明了退化的问题以及测试了我们的网络。我们证明了：1. 在残差结构下的很深的深度网络还是很好被优化的，但是很深的只是简单叠加的深度网络的误差会随着层数的增加而增加； 2. 我们很深的残差网络可以在增长网络深度的条件下继续提高精度。</p><h1 id="Deep-Residual-Learning"><a href="#Deep-Residual-Learning" class="headerlink" title="Deep Residual Learning"></a>Deep Residual Learning</h1><h2 id="Residual-Learning"><a href="#Residual-Learning" class="headerlink" title="Residual Learning"></a>Residual Learning</h2><p>让我们假设 $\mathcal H(\bf x)$ 是正常叠加一些卷积层(一个stack)的网络对应的underlying mapping. 这里的 $\bf x$ 代表的是通过这一小堆第一层的input。如果我们假设一系列的非线性层可以为我们得出复杂函数的估计，那么我们同样也可以用这一系列的非线性ceng</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这部分我们来看看这个经典结构ResNet首先被提出的文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;论文链接：&lt;a href=&quot;https://arxiv.org/pdf/1512.03385.pdf&quot;&gt;https://arxiv.org/pdf/1512.03385.pdf&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="论文阅读" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
    <category term="Computer Vision" scheme="http://yoursite.com/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>干货 | 几种目标检测的网络和变化</title>
    <link href="http://yoursite.com/2020/07/22/%E5%B9%B2%E8%B4%A7-%E5%87%A0%E7%A7%8D%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/07/22/%E5%B9%B2%E8%B4%A7-%E5%87%A0%E7%A7%8D%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-22T19:42:46.000Z</published>
    <updated>2020-09-24T19:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selective-Search"><a href="#Selective-Search" class="headerlink" title="Selective Search"></a>Selective Search</h1><h1 id="RCNN"><a href="#RCNN" class="headerlink" title="RCNN"></a>RCNN</h1><h1 id="Fast-RCNN"><a href="#Fast-RCNN" class="headerlink" title="Fast-RCNN"></a>Fast-RCNN</h1><p>为了改进之前RCNN结构中，生成的conv feature需要通过SVM，造成大量的时间损耗。Girshick又改进了之前的网络结构,提出了Fast RCNN。</p><p>Fast RCNN是在SPP和RCNN的基础上提出的。</p><p>RCNN我们在上个部分已经提过了，那么SPP网络是什么呢？</p><ul><li><p>SPP的全称是Spatial Parimid Pooling，主要是在不同的空间尺度上进行池化，提取不同空间尺度的特征，防止Proposal在进入RCNN网络时rescale到固定尺寸(224 x 224)时图形产生的形变和图片的变化。</p></li><li><p>SPP在使用的过程中是将全图划分成不同尺寸的grid（比如 1 x 1的grid的就是原图本身， 2x 2的grid是将原图分为4份，其中每一份cell的长宽都是原图长宽的一半）, 然后将每一个grid生成的pooling之后的结果组合在一起，产生一个固定大小的feature作为SPP的输出。对于输入的每一个channel都会生成grid。</p></li><li><p>举个例子，假如现在我们输入是一个 256 x 256 x 3 的feature</p><ol><li><p>针对每一层，生成 1x1 的grid，然后做max pooling，得到一个 1 x 3 的feature</p></li><li><p>针对每一层，生成 2 x 2的grid，然后做max pooling，得到一个 4 x 3的feature</p></li><li><p>针对每一层，生成 4 x 4的grid，然后做max pooling，得到一个 16 x 3 的feature</p><p>…</p></li></ol><p>最后将这些feature拼接起来生成的整个feature是固定大小的输出。（因为我们grid的大小是固定的，所以如果输入feature的尺寸发生变化，那么只有grid中每个cell的大小会发生变化，但是gird中cell的个数是固定不变的，所以最后通过ROI pooling的生成结果的尺寸是不变的。）</p></li></ul><p>那么对于Fast RCNN来说，它的输入是一张图片，以及一些proposal，这些proposal的大小各不相同，我们用(r, c, h, w) 来表示每一个proposal region。 r c表示左上角的坐标点，h w 表示这个框的长宽。</p><p>Fast RCNN的主要过程是，我们将原图通过特征提取网络，生成一个conv feature map，然后在这个map上面根据之前所说的proposal的信息，提取出proposal的位置，并对其进行ROI pooling。生成的ROI pooling是一个长度固定的feature，并且这里我们只用一次 H x W 的grid提取，也就是说通过ROI pooling之后生成的feature的长度是 H x W x d (这里d是输入ROI pooling之前的feature的维度)。生成的feature之后会通过两个网络，一个连接到softmax用来确定我这张图片上有哪些物体，另一个用来确定预测出的物体的bounding box是什么。</p><p>（receptive field为什么会更大）</p><h1 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h1><p>目标检测的网络发展至此，还有一个重要的需要依靠外界实现的输入，那就是proposal</p><p>Faster RCNN的出现解决了需要依靠外界条件得到proposal region的情况，实际上Faster RCNN就是一个Region Proposal Network + Fast RCNN的网络结构。那么就主要介绍一下生成proposal的网络： RPN</p><p>RPN的主要目的就是寻找proposal，这时候我们就建立一个sliding window，然后以这个sliding window为中心，构建不同尺寸和长宽比的anchor来找到合适的proposal region。</p><p>训练RPN的时候，主要分为两个方面的cost，一方面是二维向量表示所圈到的proposal是否是一个物体，另一个是四维向量来表示所圈到的坐标信息。proposal是否为物体主要是根据proposal和target的IoU来判定，如果IoU大于0.7或者IoU是这些anchor里面最大的，那么这个anchor就被称作是positive的结果；反之如果IoU小于0.3就是negative的结果。bounding box的预测值是输入在regression网络中进行训练的。</p><p>文章中使用的anchor为9个。</p><p>但是使用RPN还存在一个问题就是因为我们的anchor的大小都是固定的，那么一个特别大或者特别小的物体就可能无法被估计（在感受野外）或者被找到。这时候可以通过训练不同的RPN在不同的尺度下进行proposal的估计，在这样产生的proposal的感受野也不同。</p><p>（感受野是怎么确定的）</p><h1 id="MTCNN"><a href="#MTCNN" class="headerlink" title="MTCNN"></a>MTCNN</h1><p>MTCNN的全称是multi-task cascaded convolutional neural network，主要是用来进行人脸的detection的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Selective-Search&quot;&gt;&lt;a href=&quot;#Selective-Search&quot; class=&quot;headerlink&quot; title=&quot;Selective Search&quot;&gt;&lt;/a&gt;Selective Search&lt;/h1&gt;&lt;h1 id=&quot;RCNN&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
    <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
    <category term="Object Detection" scheme="http://yoursite.com/tags/Object-Detection/"/>
    
  </entry>
  
  <entry>
    <title>干货 | 几种常见的特征检测子</title>
    <link href="http://yoursite.com/2020/07/20/%E5%B9%B2%E8%B4%A7-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2020/07/20/%E5%B9%B2%E8%B4%A7-%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AD%90/</id>
    <published>2020-07-20T12:59:51.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HOG-SVM"><a href="#HOG-SVM" class="headerlink" title="HOG + SVM"></a>HOG + SVM</h1><p>我们常常会选取一些图片中的特征来代表这个图片中的内容，图片中物体的edge是很有力的特征。这样来说，我们可以用canny找到图片中的物体的edge。但是找到的edge只是大小，并没有gradient的信息。所以在这里我们提取gradient，生成它的特征信息。</p><ol><li><p>输入图片</p></li><li><p>对图片进行颜色和对比度的归一化处理</p></li><li><p>计算gradient：</p><p>这一项稍微复杂一些，我们分开来说。</p><ul><li>首先将图片分割成一个个 $8 \times 8$ pixel大小的cell，这样的话，一个长度为height, 宽度为 width的图片能生成的cell的个数就是 $\frac{height}{8} \times \frac{width}{8}$. </li><li>对于每一个cell中的每一个pixel都有我们计算的gradient的方向，将0-360划分为8个方向，然后将 $8 \times 8$ pixel中每一个pixel的方向都统计在这八个方向上，这样一来，我们的这64个pixel就可以保存为一个 $1\times 8$ 的histogram vector；</li><li>由于  $8 \times 8$ pixel 的感受面积还是比较小，可能无法感知到光线的变化，所以我们进一步将一个 $2 \times 2$ 的cell当做一个block，这样，对于一个block中的每一个cell，他都有一个 $1 \times8$的vector，这样四个cell的histogram放在一起就是一个 $ 1 \times 32$ 的histogram vector。</li><li>然后将这个$ 1 \times 32$ 的histogram vector进行归一化处理，就得到了这一张图的一个特征。对于整个图来讲，我们就得到了一个 $(\frac{height}{8} \times \frac{width}{8}\times32)$ 的特征。</li></ul></li><li><p>我们将histogram vector拿出来作为图片是否是某种物体的特征，然后将这些特征放入一个SVM中，设置一个score，来判定是否有我们想要的物体。</p></li></ol><h1 id="Viola-Jones-face-detector-Harr-Adaboost"><a href="#Viola-Jones-face-detector-Harr-Adaboost" class="headerlink" title="Viola - Jones face detector (Harr+Adaboost)"></a>Viola - Jones face detector (Harr+Adaboost)</h1><ol><li>Harr-like feature</li><li>Integral of image</li><li>Adaboost</li><li>Concatenate classifier</li></ol><h1 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h1><ol><li><p>Space - Scale Extrema detection</p><p>SIFT算子的第一步要先重视这里的scale invariant，我们希望SIFT能找到的特征是在各种尺度的情况下都可以成立的。因此，我们需要构建不同的尺度来寻找特征点。</p><ul><li><p>使用DOG来代替LOG</p><p>通常情况下，我们用Laplacian of Gaussian来寻找图片中的边缘信息（先平滑，再二次求导），但是用LOG的话计算量会比较大而且复杂，于是我们就发现，可以用两个不同sigma值平滑的gaussian分布做差，得到和LOG类似的形状，也可以实现边缘检测。</p><p>提取不同的高斯平滑后的边缘，我们可以得到一个octave。</p><p>那为什么我们要octave呢，可能是因为在不同的高斯平滑下，我们找到的边缘是不同的。平滑程度大，找到的边界就会少一些，平滑程度小，产生的噪声就会强一些。不同的平滑程度下，我们得到的是不同的边界。</p></li><li><p>改变尺度，寻找边缘</p><p>在不同尺度下，找相同的特征这个思路很直观。比如说一棵树，我们在远处模糊的看到他的时候，他是一棵树；当我们走进之后，这个数会变得更加清晰，我们还能看出来他是一棵树。这就说明有一些特征信息是具有尺度不变性的。</p><p>所以，除了在原图上做blur，我们还需要改变原图的resolution，然后再做一系列的blur。这样对于一张图，我们会得到不同的几个octaves</p></li></ul></li><li><p>Keypoint Localization</p><p>确定keypoint的步骤分为两步，找到key point，去掉contrast比较弱的key point</p><ul><li>找到key point，</li></ul></li><li><p>Orientation Assignment</p></li><li><p>Local Descriptor Creation</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HOG-SVM&quot;&gt;&lt;a href=&quot;#HOG-SVM&quot; class=&quot;headerlink&quot; title=&quot;HOG + SVM&quot;&gt;&lt;/a&gt;HOG + SVM&lt;/h1&gt;&lt;p&gt;我们常常会选取一些图片中的特征来代表这个图片中的内容，图片中物体的edge是很有力的特征。这</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>干货 | Canny Edge Detector</title>
    <link href="http://yoursite.com/2020/07/19/%E5%B9%B2%E8%B4%A7-Canny-Edge-Detector/"/>
    <id>http://yoursite.com/2020/07/19/%E5%B9%B2%E8%B4%A7-Canny-Edge-Detector/</id>
    <published>2020-07-20T02:15:18.000Z</published>
    <updated>2020-09-24T19:51:36.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Machine-Learning-2020 | Lecture#5 Convolutional Neural Network</title>
    <link href="http://yoursite.com/2020/07/15/Machine-Learning-2020-Lecture-5-Convolutional-Neural-Network/"/>
    <id>http://yoursite.com/2020/07/15/Machine-Learning-2020-Lecture-5-Convolutional-Neural-Network/</id>
    <published>2020-07-15T14:32:54.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先就迎来了深度神经网络的第一个基础的部分：CNN</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先就迎来了深度神经网络的第一个基础的部分：CNN&lt;/p&gt;
</summary>
      
    
    
    
    <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="lecture notes" scheme="http://yoursite.com/tags/lecture-notes/"/>
    
    <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Machine-Learning-2020 | Lecture#4 Deep Learning Preparation - Backpropagation</title>
    <link href="http://yoursite.com/2020/07/05/Machine-Learning-2020-Lecture-4-Deep-Learning-Preparation-Backpropagation/"/>
    <id>http://yoursite.com/2020/07/05/Machine-Learning-2020-Lecture-4-Deep-Learning-Preparation-Backpropagation/</id>
    <published>2020-07-05T21:07:44.000Z</published>
    <updated>2020-09-24T19:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分还是deep learning的准备课程，就是反向传播。</p><p>在更新神经网络参数的过程中，反向传播是很重要的一步。那么如何有效得计算反向传播也同样重要。</p><h1 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h1><p>首先我们来捋一捋神经网络的正向传播过程。</p><ul><li>输入 $\bf x = \left[\begin{equation}\begin{array}{c}\bf x<em>1\\bf x_2\end{array}\end{equation}\right] $  ,第$i$ 层的权重为 $\bf w = \left[\begin{equation}\begin{array}{c|c}\bf w</em>{11} \ w<em>{12}\ \bf w</em>{21} \ w_{22} \end{array}\end{equation}\right] $, 激活函数为 $\sigma(z)$， 通过激活函数的结果为 $\bf a$， 然后$\bf a$ 再作为下一层的输入通过神经元，通过激活函数，直到最后一层得到Loss function $\bf L$</li><li>图</li></ul><h1 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h1><p>反向传播的过程是为了求得gradient然后更新每一层的每个神经元的参数。</p><h2 id="Chain-Rue"><a href="#Chain-Rue" class="headerlink" title="Chain Rue"></a>Chain Rue</h2><script type="math/tex; mode=display">\frac{\part z}{\part s} = \frac{\part z}{\part x}\cdot\frac{\part x}{\part s} + \frac{\part z}{\part y}\cdot \frac{\part y}{\part s}\\\frac{\part z}{\part s} = \frac{\part z}{\part x} \cdot \frac{\part x}{\part s}</script><script type="math/tex; mode=display">\frac{\part L(\theta)}{\part w} = \sum \limits_{n = 1}^{N}\frac{\part C^{n}(\theta)}{\part w}</script><p>这里的 $n$ 表示的是第 $n$ 个training example。那我们只要计算一个example的更新就可以了</p><h2 id="Forward-Pass"><a href="#Forward-Pass" class="headerlink" title="Forward Pass"></a>Forward Pass</h2><p>图</p><p>根据Chain rule和我们知道的神经网络结构图，对于一层中的一个神经元，我们可以得到：</p><script type="math/tex; mode=display">z = x_1 w_1 + x_2 w_2 + b\\a = \sigma(z)</script><p>从这一层中可以看出，如果我们要求  $w_1$ 对 $C$ 的导数，我们能做的就是求 $z$ 对 $C$ 的倒数乘以 $w_1$ 对 $z$ 的导数。即，</p><script type="math/tex; mode=display">\frac{\part C}{\part w_1} = \frac{\part z}{\part w_1}\cdot \frac{\part C}{\part z}</script><p>那么，$\frac{\part z}{\part w_1}$ 很好计算，通过之前神经元的结构的例子，我们可以得出 $\frac{\part z}{\part w_1}$ 就是 $w_1$前面连接的输入，即$x_1$</p><p>而后面的 $\frac{\part C}{\part z}$ 则不能直接算出。</p><p>这样一来，我们把所有接在要求的参数前面的输入都保存下来，这样就可以得到 $\frac{\part C}{\part w_1}$ 导数的第一项。</p><h2 id="Backward-Pass"><a href="#Backward-Pass" class="headerlink" title="Backward Pass"></a>Backward Pass</h2><p>那怎么求  $\frac{\part C}{\part z}$ 呢？</p><p>根据Chain Rule, 我们可以接着计算 $\frac{\part C}{\part z} = \frac{\part a}{\part z}\cdot \frac{\part C}{\part a}$ 。在这个式子中，$\frac{\part a}{\part z}$ 很好算，因为我们知道激活函数，那么就很容易计算激活函数的导数。那又出现了一个令人头疼的项，就是 $\frac{\part C}{\part a}$。</p><p>$\frac{\part C}{\part a}$ 如果接着使用chain rule的话，可以看出 $a$ 是通过  $z’$ 和 $z’’$ 两项来共同影响最后的结果 $C$ 的，所以我们可以得到</p><script type="math/tex; mode=display">\frac{\part C}{\part a} = \frac{\part z'}{\part a}\cdot \frac{\part C}{\part z'} + \frac{\part z''}{\part a}\cdot \frac{\part C}{\part z''}</script><p>而 $\frac{\part z’}{\part a}$ 和 $\frac{\part z’’}{\part a}$ 可以通过 $z’$ 和 $z’’$ 之前接的项来表示，而这时候我们要求的导数又变成了$\frac{\part C}{\part z’}$ 和 $\frac{\part C}{\part z’’}$. 这一项其实和 $\frac{\part C}{\part z}$ 是相似的, 所以计算 $\frac{\part C}{\part z’}$ 的过程是要重复 计算 $\frac{\part C}{\part z}$ 的过程 。</p><p>总结一下，</p><script type="math/tex; mode=display">\frac{\part C}{\part z} = \sigma '(z)\left [w_3\frac{\part C}{\part z'} + w_4 \frac{\part C}{\part z''}\right ]</script><p>所以看到了吗，在每一层，我们如果想要计算cost function对这层的参数的导数，就要历经这一层之后的所有层，然后求导，这就造成了一个很大而且重复的工作量。所以我们在这里考虑将这些数值保存起来。</p><p>怎么保存呢？</p><ul><li><p>先考虑最后的情况</p><p>假设我们的 $z’$ 是最后一层，过了这一层之后我们的 $z’$再过一个激活层就可以得到输出 $y = \sigma(z’)$</p><p>那么，此时的 $\frac{\part C}{\part z’} = \frac{\part y}{\part z’}\cdot \frac{\part C}{\part y}$. 这里等式右边的第一项就是激活函数的导数，即 $\sigma’(z’)$ ；而第二项是根据cost function决定的，是一个constant。那这样我们就可以分别得到 $\frac{\part C}{\part z’}$ 和 $\frac{\part C}{\part z’’}$ 的值。</p></li><li><p>考虑一般情况</p><p>假设现在 $z’$ 不是最后一层，那么根据刚才算出来的最后一层的值和 $\frac{\part C}{\part z} = \sigma ‘(z)\left [w_3\frac{\part C}{\part z’} + w_4 \frac{\part C}{\part z’’}\right ]$ ，我们可以得到 $\frac{\part C}{\part z}$ 的值。这个式子也可以看做是个反向传送的神经网络。</p></li></ul><p>那么我们最后要算的 $\frac{\part C}{\part w_1}$就可以用forward pass 和backward pass两部分保存的参数相乘得到。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一部分还是deep learning的准备课程，就是反向传播。&lt;/p&gt;
&lt;p&gt;在更新神经网络参数的过程中，反向传播是很重要的一步。那么如何有效得计算反向传播也同样重要。&lt;/p&gt;
&lt;h1 id=&quot;正向传播&quot;&gt;&lt;a href=&quot;#正向传播&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="lecture notes" scheme="http://yoursite.com/tags/lecture-notes/"/>
    
    <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Machine-Learning-2020 | Lecture#4 Deep Learning Preparation - Recipe for Deep Learning</title>
    <link href="http://yoursite.com/2020/07/04/Machine-Learning-2020-Lecture-4-Deep-Learning-Preparation-Recipe-for-Deep-Learning/"/>
    <id>http://yoursite.com/2020/07/04/Machine-Learning-2020-Lecture-4-Deep-Learning-Preparation-Recipe-for-Deep-Learning/</id>
    <published>2020-07-04T20:46:52.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们在一开始介绍Machine Learning的时候提到找寻最佳模型的方法，同样这散步也可以应用在deep learning上面：</p><ul><li>Step 1: Define a set of function - 定义神经网络的类型结构和框架</li><li>Step 2: Goodness of function - 定义评价神经网络的cost function</li><li>Step 3: Pick the best function - 训练能够得到最佳效果的神经网络的各种参数</li></ul><p>这部分的课程要介绍的是，当我们在训练深度神经网络的时候，如果训练的效果不好，究竟是哪部分出了问题呢？在训练的时候，我们要查看哪些训练结果呢？</p><a id="more"></a><p>和传统的Machine Learning不同之处在于，我们在训练神经网络的时候需要查看的是两方面的误差： <strong>Training error</strong> 和 <strong>Testing error</strong>。而传统Machine Learning中, 我们只需要尽量减小训练误差,然后得到相符的模型参数就好了，实在不行我们就换模型。但是在深度神经网络中，由于我们的选择更多，不确定性也会变多，有可能选择的模型没错，但是一些参数或者中间的连接层有问题，也会造成误差变大。</p><h1 id="查看-Training-set"><a href="#查看-Training-set" class="headerlink" title="查看 Training set"></a>查看 Training set</h1><p>在训练模型的时候，我们首先接触的就是training set得到的error。如果本来你training set的error就很大的话，那无论怎样，在testing set上得到的误差也不会很小。</p><p>如果在training set上面的误差比较大，那么我们可以尝试一下几个方式来调整：</p><h2 id="调整-Activation-Function"><a href="#调整-Activation-Function" class="headerlink" title="调整 Activation Function"></a>调整 Activation Function</h2><p>我们在之前regression和classification中使用的activation function经常是 sigmoid function。sigmoid function可以很好的帮我们解决二分类的问题，但是它也有一些缺点。</p><p>在深度神经网络中，我们的激活函数通常是放在层与层之间的，这样的话，如果我们有一个很多层的神经网络，且每一层之间都用sigmoid连接，那么我们在利用gradient descent 求解的时候，就会出现连续对很多的sigmoid function求导，这样的话，就会出现梯度消失的问题。（近output的参数训练到了，但是近input的参数并没有被训练到）</p><blockquote><p>为什么Sigmoid Function会造成梯度消失？</p><ol><li>直观来讲，如果我们有一个很深的神经网络，每一层都用sigmoid来连接，那么 $\frac{\part C}{\part w}$ 代表的是我们某一个参数对cost function的偏导数。可以想象，在离输入层越近的地方，如果我们改变一点参数的值，它对cost function的影响并不会很大。因为改变了一点参数$w$ 的值，在层层经过sigmoid function之后，它的影响会被弱化，以至于到最后一层，对于cost function的影响就会变得很小。所以这会造成梯度消失。</li><li>数学上来讲，我们来看看gradient descent的公式。</li></ol></blockquote><p>这样的话，我们的解决方案就是： 改变激活函数</p><ol><li><p>ReLU</p><p>ReLU就很直接，小于零的部分为0，大于零的部分为属于本身。虽然我们在使用ReLU的时候，有可能因为输入值小于零得到的输出就小于零了，但是我们的神经网络并不会因此变为线性。因为对于这个神经网络整体来说，还是nonlinear的，只有我们在对input做出的改动特别小以至于没有改变input的region（大于零和小于零的部分保持不变）的时候，才可能是linear的，所以当我们改变了输入的值的时候，对于网络整体来说还是non-linear的。</p><p>对于ReLU的改进也有很多种，比如 Leaky ReLU（将小于零的部分也赋予一个斜率比较小的直线）， Parametric ReLU（将小于零的部分的直线的斜率也作为一个被学习的参数）， Maxout（学习这个piecewise的两端的直线究竟是怎样的）</p><p>ReLU还存在一个问题就是0点是不可导的，对于这个的解释是，一般我们不一定就会正好取到0这个点。</p></li><li><p>MaxOut</p><p>上面提到了Maxout是已经不仅仅限于ReLU方程的那个样子了，而是我们要学习这个piece-wise的线性方程究竟张什么样，可以说ReLU是Maxout的一种特殊形式。</p><p>Maxout这个激活函数其实和CNN中的max pooling差不多，就是在通过这个激活层的时候，没有具体的函数，而是我们要取的是输出里面的最大值。那么存在的问题就是在反向传播的过程中该如何求导呢？因为我们在输出的时候取的是较大值，那么就等于说在这部分，网络变成了线性的。其实训练的就只有被选择了的神经元的参数了。</p></li></ol><h2 id="调整Adaptive-Learning-Rate"><a href="#调整Adaptive-Learning-Rate" class="headerlink" title="调整Adaptive Learning Rate"></a>调整Adaptive Learning Rate</h2><p>在训练的时候，最长遇到的问题或者说无法确定的事是害怕被困在Local Minima中。这样的话，我们就需要做一些调整来防止训练的时候陷入泥潭。</p><ol><li><p>Adagrad</p><p>对于Gradient Descent而言，普遍的更新参数的公式就是: $w^{t+1} = w^{t} - \eta\frac{\part L}{\part w^t} = w^t - \eta g^t$</p><p>但是这个更新方程存在的问题就是，对于所有的参数，我们更新时候的学习率是相同的，那么就导致，再从头到尾的时间里，我们一直是秉承着同一学习率的。但是，我们希望我们的learning rate可以有自己的适应过程，可与根据之前的变化来改变自身的大小。这时候，我们引入了Adagrad</p><p>Adagrad 把之前学习过的gradient放在了更新的过程中。</p><script type="math/tex; mode=display">w^{t+1} = w^t - \frac{\eta}{\sqrt{\sum\limits_{i=0}^{t}(g^i)^2}}g^t</script><p>这个式子就表现了说，如果我们之前的gradient就变化很大，那就说明此处比较陡峭，我们希望学习率稍微小一些，不要错过正确的点。而如果之前的gradient变化比较小，那就说明这部分比较平坦，我们就希望学习率大一些，每次走的多一些。</p></li><li><p>RMSProp</p><p>但是Adagrad存在一个问题，那就是，我们的假设只在当变化的表面比较有规律的时候才可以实现。但是，我们在训练的时候并不能保证前面的cost surface平坦，后面也会一直平坦，有可能在某一个地方就突然变的很陡峭。在这种时候${\sqrt{\sum\limits_{i=0}^{t}(g^i)^2}}$ 就会造成困扰，因为之前的$g^i$ 很小，所以累积起来的平方和也很小，导致我们的自适应学习率会很大，那如果这时候突然来了一个稍微陡峭的坡路，我们的这个很大的学习率是停不下来的。所以很容易错过合适的最低点。</p><p>所以这时候，我们就期望给之前累积的gradient和当前的gradient加上权重。这时候就引入了RMSProp。</p><script type="math/tex; mode=display">w_{t+1} = w_{t} - \frac{\eta}{\sqrt{v_{t}}}g_t\\ v_{t} = \alpha v_{t-1} +(1 - \alpha)g_{t}^2, v_0 = g_0</script><p>如果用历史gradient来表示 $v<em>t$ 我们可以得到 $v</em>{t+1} = (1-\alpha)g<em>{t}^2 + \alpha(1 - \alpha)g</em>{t-1}^2 + \alpha^2(1-\alpha)g_{t-2}^2+…$</p><p>那如果我们将 $\alpha$ 设置的比较小，那么 $\alpha^{t-i}$ 会作用在$g_i$ 上面，使得其对后面的影响越来越小，而离 $g_t$越近，影响越大。</p></li><li><p>Momentum</p><p>在上面更新参数的过程我们都是运用了$w^{t+1} = w^t - \eta g^t$ 这个式子，做出的改变都是改变$\eta$ 的数值。</p><p>但还有另一种思路是利用momentum的知识，让我们在更新 $t$ 时刻的参数的时候，也考虑一下之前$t-1$时刻的参数对他的影响。也就是利用</p><script type="math/tex; mode=display">w_{t+1} = w_t + \lambda v_{t} - \eta g_t\\ v_t =  \lambda v_t - \eta g_t = -\eta g_{t-1}- \lambda\eta g_{t-2} - \lambda^2\eta g_{t-3} - ...</script><p>这里的lambda也是一个参数，表示的是对之前gradient的参考权重，表示的是之前gradient的方向，对现在gradient方向的影响。</p></li><li><p>Adam = RMSProp + Momentum</p><p>同时考虑变化 学习率 $\eta$ 和变换规则加起来，我们就可以得到Adam</p></li></ol><script type="math/tex; mode=display">   w_{t+1} = w_t - \frac{\eta}{\sqrt{\hat v_{t+1}}+\epsilon}\hat m_{t+1}   \\ m_{t+1} = \beta_1 m_t + (1 - \beta_1)g_t   \\ v_{t+1} = \beta_2 v_{t} + (1-\beta_2)g_t^2   \\ \hat m_{t+1} = \frac{m_{t+1}}{1 - \beta_1^{t+1}}   \\ \hat v_{t+1} = \frac{v_{t+1}}{1 - \beta_1^{t+1}}</script><h1 id="查看-Validation-set"><a href="#查看-Validation-set" class="headerlink" title="查看 Validation set"></a>查看 Validation set</h1><p>之前的那些步骤都是要当我们的training set本身就没得到什么好结果的时候，需要更改的内容。</p><p>那么如果我们的training set本身答到了好的准确率，但是我们的validation/test上面的结果很差的时候应该怎么办呢。这时候说的是带有标签用来调整参数的验证集，而不是未知标签的测试集。</p><h2 id="Early-stopping"><a href="#Early-stopping" class="headerlink" title="Early stopping"></a>Early stopping</h2><p>其实这种状况发生的时候，我们可以断定是过拟合了，所以按照之前我们对待其他machine learning algoorithm的方式，我们需要尽早结束训练。</p><h2 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h2><p>那么我们来看看只有神经网络才具有的正则化的步骤。正则化其实就是在cost function的后面加上一个限制的term。</p><ol><li><p>L1正则化</p><p>$L’(w) = L(w) + \lambda ||w||_1$ </p><p>这里的 $L’(w)$ 表示的是加了正则项之后的损失函数，并不是求导。</p><p>那么在加了正则项之后，我们在梯度下降的过程中对参数求导会得到什么呢？</p><p>$\frac{\part L’}{\part w} = \frac{\part L}{\part w} + \lambda sgn(w)$ </p><p>因为我们的正则项是绝对值，所以得到的 $sgn(w)$ 就正值为+1 负值为 -1</p><p>那么我们看看在更新参数的时候：</p><script type="math/tex; mode=display">w^{t+1} = w^{t} - \eta \frac{\part L}{\part w} - \eta \lambda sgn(w^t)</script><p>也就是说，我们在更新参数的时候，除了之前正常的减掉参数对损失函数的导数，还要再减去一个固定的值。那无论我们的 参数 $w^t$ 是大是小，更新的时候减掉的都是一个固定的值，所以参数比较小的时候训练出来的结果会得到接近0的数，但参数比较大的时候，训练出来的结果还是会很大。这样的话，就会消除一些特征，有利于特征的选择，得到稀疏的结果。</p></li><li><p>L2正则化</p><p>$L’(w) = L(w) + \lambda \frac{1}{2}||w||_2$</p><p>在加上正则项之后再对损失函数求导，我们会得到什么呢：</p><script type="math/tex; mode=display">\frac{\part L'}{\part w} = \frac{\part L}{\part w} + \lambda w</script><p>这时候我们在更新参数的时候就会得到:</p><script type="math/tex; mode=display">w^{t+1} = w^t - \eta \frac{\part L}{\part w} - \eta \lambda w^t = (1 - \eta \lambda)w^t - \eta \frac{\part L}{\part w}</script><p>和之前的加上L1正则项不同的是，我们这里加上L2Z正则项更新参数的时候，等于在之前的参数前面乘以一个比较小的量，造成一个 weight decay。这样一来，不管我们之前的参数 $w^t$ 是大是小，每次更新的时候都会被按照相同的比率衰减，最后 比较大的参数会下降到比较小，但是比较小的参数也不会下降特别多。就会使得所有的参数的值比较平均，可以减弱某些权重，让gradient descent朝比较正确的方向走。</p></li></ol><h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><p>Dropout可以说是最具神经网络结构特征的一种防止过拟合的方法了。</p><p>它的主要思想就是我们在训练的过程中，对于每一层而言，放弃 $p\%$ 的神经元，只对剩下的 $(1 - p\%)$ 个神经元进行训练。而在每一个训练的batch里面，我们对于神经元的放弃都是随机的，这样可以保证每一个神经元都可以被训练到。</p><p>主要需要注意的地方就是：在test的时候，我们要保存所有的神经元，但是每一层的的weight都要乘以 $(1 - p\%)$ 来保证和训练的时候总weight达到一致的需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在一开始介绍Machine Learning的时候提到找寻最佳模型的方法，同样这散步也可以应用在deep learning上面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Step 1: Define a set of function - 定义神经网络的类型结构和框架&lt;/li&gt;
&lt;li&gt;Step 2: Goodness of function - 定义评价神经网络的cost function&lt;/li&gt;
&lt;li&gt;Step 3: Pick the best function - 训练能够得到最佳效果的神经网络的各种参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这部分的课程要介绍的是，当我们在训练深度神经网络的时候，如果训练的效果不好，究竟是哪部分出了问题呢？在训练的时候，我们要查看哪些训练结果呢？&lt;/p&gt;</summary>
    
    
    
    <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="lecture notes" scheme="http://yoursite.com/tags/lecture-notes/"/>
    
    <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm | Binary Heap</title>
    <link href="http://yoursite.com/2020/07/02/Algorithm-Binary-Heap/"/>
    <id>http://yoursite.com/2020/07/02/Algorithm-Binary-Heap/</id>
    <published>2020-07-02T18:35:12.000Z</published>
    <updated>2020-10-17T21:13:40.172Z</updated>
    
    <content type="html"><![CDATA[<p>参考网页：</p><p><a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary Heaps/heaps.html">https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary%20Heaps/heaps.html</a></p><h1 id="Binary-Heap的定义"><a href="#Binary-Heap的定义" class="headerlink" title="Binary Heap的定义"></a>Binary Heap的定义</h1><p>这个堆又分为最小堆和最大堆，所以这里直接用Binary Heap来代替，叫二分堆（？）</p><p>Binary heap是一个完整的二叉树,并且满足堆的排序性质，即每次都可以pop出来最大或者最小值，由于这种性质，我们也将堆称作priority queue</p><blockquote><p>完整二叉树说的是除了最后行,其他的分支都被填满的树</p></blockquote><p>根据堆的排序标准,它主要可以被分为两种:</p><ul><li>最小堆min-heap: 对于每一个节点来说，他都大于或者等于它的父节点</li><li>最小堆max-heap：对于每一个节点来说，他都小于或者等于它的父节点</li></ul><p>这里我们只用最小堆minheap来举例。</p><h2 id="Array-Implementation"><a href="#Array-Implementation" class="headerlink" title="Array Implementation"></a>Array Implementation</h2><p>在返回堆代表的序列时，是按照遍历每一层的顺序，因此最小堆结构的整体并不是有序的结构，只可能是部分有序，且第一项是最小值。</p><p><img src="../images/Screen%20Shot%202020-07-05%20at%2013.43.19.png" alt="Screen Shot 2020-07-05 at 13.43.19"></p><h2 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h2><p>往最小堆中插入一个数字，是先将该数字放在最小堆的末尾，然后和它的parent相比较，如果大于它的parent那就正好不用移动，如果小于它的parent那么就将它和parent换位置，直到到达符合小于parent的位置。</p><h2 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h2><p>删除最小值的时候是先将root（最上面的parent，也就是我们的最小值）和堆的最后一位换位置，然后把它换下来。换在最上面的值会和左右两边的parent进行比较，然后往下放，直到换到一个合适的位置（符合最小堆性质）。</p><h2 id="Heap-sort"><a href="#Heap-sort" class="headerlink" title="Heap sort"></a>Heap sort</h2><p>就是按照刚才delete的顺序，不听去掉root的值然后进行排序，最差的时长是 <code>O(nlogn)</code></p><h1 id="Python中的heapq包"><a href="#Python中的heapq包" class="headerlink" title="Python中的heapq包"></a>Python中的heapq包</h1><p>常用的函数</p><p><strong>注意heapq里面是按照最小堆来进行整合的，所以我们每次pop出来的都是最小值。</strong></p><ul><li><p><code>heapq.heappush(*heap*, *item*)</code></p><p>Push the value <em>item</em> onto the <em>heap</em>, maintaining the heap invariant.</p></li><li><p><code>heapq.heappop(*heap*)</code></p><p>Pop and return the smallest item from the <em>heap</em>, maintaining the heap invariant. If the heap is empty, <a href="https://docs.python.org/2/library/exceptions.html#exceptions.IndexError"><code>IndexError</code></a> is raised. To access the smallest item without popping it, use <code>heap[0]</code>.</p></li><li><p><code>heapq.heapify(*x*)</code></p><p>Transform list <em>x</em> into a heap, in-place, in linear time.</p></li></ul><p><strong>如果我们想使用最大堆的话，可以再输入堆的数字前面加上负号，然后输出的时候再赋予负号</strong></p><p>Python中的heapq包也同样有</p><p><code>heapq._heapify_max(heap)</code> 这样的函数，但是目测，如果使用最大堆的话，需要一直使用隐函数的最大堆max的函数，不然的话，heap的顺序就会乱掉。</p><p>比如一开始用<code>heapq._heapify_max(nums)</code> 排列了序列，然后再 <code>heapq.heappop(nums)</code> 这样的话输出的是最大值，且pop之后的序列的最小值会换上来，所以中间的序列顺序会被打乱。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考网页：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cs.cmu.edu/~adamchik/15-121/lectures/Binary Heaps/heaps.html&quot;&gt;https://www.cs.cmu.edu/~adamchik/15-121/l</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
    <category term="二叉堆" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    
    <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm | LeetCode - July Challenge</title>
    <link href="http://yoursite.com/2020/06/30/Algorithm-LeetCode-July-Challenge/"/>
    <id>http://yoursite.com/2020/06/30/Algorithm-LeetCode-July-Challenge/</id>
    <published>2020-06-30T21:49:49.000Z</published>
    <updated>2020-09-24T19:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>【LeetCode】- July Challenge</p><p><a href="#lc441">0701 - Leetcode441 - Arranging coins - Easy</a></p><p><a href="#lc107">0702 - Leetcode107 - Binary Tree Level Order Traversal II</a></p><p><a href="#lc104">补充 - Leetcode104 - Binary Tree Level Order Traversal</a></p><p><a href="#lc957">0703 - Leetcode957 - Prison Cells After N days</a></p><p><a href="#lc264">0704 - Leetcode264 - Ugly Number II</a></p><p><a href="#lc263">补充 - Leetcode263 - Ugly Number </a></p><p><a href="#lc461">0705 - Leetcode461 - Hamming Distance</a></p><p><a href="#lc477">补充 - Leetcode477 - Total Hamming Distance - Medium</a></p><p><a href="#lc66">0706 - Leetcode66 - Plus One - Easy</a></p><p><a href="#lc463">0707 - Leetcode463 - Island Perimeter - Easy</a></p><p><a href="#lc15">0708 - 3Sum - Medium</a></p><p><a href="#lc78">0711 - Leetcode78 - Subsets - Medium</a></p><p><a href="#lc100">0713 - Leetcode100 - Same Tree - Easy</a></p><p><a href="#lc1344">0714 - Leetcode1344 - Angle Between Hands of a Clock - Medium</a></p><p><a href="#lc347">0717 - Leetcode - Top K Frequent Elements - Medium</a></p><p><a href="#lc210">0718 - Leetcode210 - Course Scheduel II - Medium</a></p><p>[0719 - Leetcode64 - ]</p><p><a href="#lc">0720 - Leetcode - Remove Linked List Elements - Medium</a></p><p><a href="#lc103">0722 - Leetcode103 - Binary Tree Zigzag Level Order Traversal - Medium</a></p><p><a href="#lc797">0724 - Leetcode797 - All Paths from source to Target - Medium</a></p><p>-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</p><h1 id="0724-Leetcode797-All-Paths-From-Source-to-Target"><a href="#0724-Leetcode797-All-Paths-From-Source-to-Target" class="headerlink" title="0724 - Leetcode797 - All Paths From Source to Target"></a>0724 - Leetcode797 - All Paths From Source to Target</h1><blockquote><p>Given a directed, acyclic graph of <code>N</code> nodes. Find all possible paths from node <code>0</code> to node <code>N-1</code>, and return them in any order.</p><p>The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: [[1,2], [3], [3], []] </span><br><span class="line">Output: [[0,1,3],[0,2,3]] </span><br><span class="line">Explanation: The graph looks like this:</span><br><span class="line">0---&gt;1</span><br><span class="line">|    |</span><br><span class="line">v    v</span><br><span class="line">2---&gt;3</span><br><span class="line">There are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>把edge储存为 ： {到达点：[上一个可能点]} 的字典格式，如果上一个可能的点存在0的话就跳出循环，否则的话就一直循环下去。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allPathsSourceTarget</span>(<span class="params">self, graph</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        edge = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(graph)):</span><br><span class="line">            link = graph[i]</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> link:</span><br><span class="line">                edge[k] += [i]</span><br><span class="line">                </span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(edge, <span class="built_in">len</span>(graph) - <span class="number">1</span>, [], ans)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, edge, lastnode, path, ans</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> lastnode == <span class="number">0</span>:</span><br><span class="line">            path = path + [<span class="number">0</span>]</span><br><span class="line">            ans.append( path[::<span class="number">-1</span>] )</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> edge[lastnode]:</span><br><span class="line">            self.dfs(edge, node, path + [lastnode], ans)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="0722-Leetcode103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#0722-Leetcode103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="0722 - Leetcode103 - Binary Tree Zigzag Level Order Traversal"></a>0722 - Leetcode103 - Binary Tree Zigzag Level Order Traversal</h1><blockquote><p>Given a binary tree, return the <em>zigzag level order</em> traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its zigzag level order traversal as:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路</p><p>BFS + 正反向输出 + flag决定</p><p>BFS输出，然后设置flag，每次都*-1 可以控制正反向输出。</p><h1 id="0720-Leetcode-Remove-Linked-List-Elements"><a href="#0720-Leetcode-Remove-Linked-List-Elements" class="headerlink" title="0720 - Leetcode - Remove Linked List Elements"></a>0720 - Leetcode - Remove Linked List Elements</h1><blockquote><p>Remove all elements from a linked list of integers that have value <strong><em>val\</em></strong>.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>设置dummy node，查看next.val是否和要去掉的val相同，如果相同，定义next = next.next. 指针不动；如果不同，指针后移一位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">self, head, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        head = dummy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> head.<span class="built_in">next</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span>.val == val:</span><br><span class="line">                <span class="keyword">if</span> head.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">                    head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head = head.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1 id="0718-Leetcode210-Course-Scheduel-II"><a href="#0718-Leetcode210-Course-Scheduel-II" class="headerlink" title="0718 - Leetcode210 - Course Scheduel II"></a>0718 - Leetcode210 - Course Scheduel II</h1><blockquote><p>There are a total of <em>n</em> courses you have to take, labeled from <code>0</code> to <code>n-1</code>.</p><p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code></p><p>Given the total number of courses and a list of prerequisite <strong>pairs</strong>, return the ordering of courses you should take to finish all courses.</p><p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p></blockquote><p>解题思路：</p><ol><li><p>DFS</p></li><li><p>Node in degree（入度）</p><p>当我们把pre课程当做出发点，而现在要选的课程当做目的地</p></li></ol><h1 id="0717-Leetcode347-Top-K-Frequent-Elements"><a href="#0717-Leetcode347-Top-K-Frequent-Elements" class="headerlink" title="0717 - Leetcode347 - Top K Frequent Elements"></a>0717 - Leetcode347 - Top K Frequent Elements</h1><h1 id="0714-Leetcode1344-Angle-Between-Hands-of-a-Clock"><a href="#0714-Leetcode1344-Angle-Between-Hands-of-a-Clock" class="headerlink" title="0714 - Leetcode1344 - Angle Between Hands of a Clock"></a>0714 - Leetcode1344 - Angle Between Hands of a Clock</h1><blockquote><p>Given two numbers, <code>hour</code> and <code>minutes</code>. Return the smaller angle (in degrees) formed between the <code>hour</code> and the <code>minute</code> hand.</p></blockquote><p>解题思路：</p><p>就直接写，然后钝角转化为 360 - 本身</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">angleClock</span>(<span class="params">self, hour, minutes</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type hour: int</span></span><br><span class="line"><span class="string">        :type minutes: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        angle_h = (hour%<span class="number">12</span>) * <span class="number">30</span> + minutes * <span class="number">0.5</span></span><br><span class="line">        </span><br><span class="line">        angle_m = minutes * <span class="number">6</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(angle_h, angle_m)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(angle_h - angle_m) &gt; <span class="number">180</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">360</span> - <span class="built_in">abs</span>(angle_h - angle_m)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(angle_h - angle_m)</span><br><span class="line">       </span><br></pre></td></tr></table></figure><h1 id="0713-Leetcode100-Same-Tree"><a href="#0713-Leetcode100-Same-Tree" class="headerlink" title="0713 - Leetcode100 - Same Tree"></a>0713 - Leetcode100 - Same Tree</h1><blockquote><p>Given two binary trees, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p></blockquote><p>解题思路：</p><p>Recursive - 分别判断每个节点是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">self, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.checkNode(p, q)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkNode</span>(<span class="params">self, node1, node2</span>):</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">and</span> <span class="keyword">not</span> node2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node1 <span class="keyword">or</span> <span class="keyword">not</span> node2 <span class="keyword">or</span> node1.val != node2.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.checkNode(node1.left, node2.left) <span class="keyword">and</span> self.checkNode(node1.right, node2.right)</span><br></pre></td></tr></table></figure><h1 id="0711-Leetcode78-Subsets"><a href="#0711-Leetcode78-Subsets" class="headerlink" title="0711 - Leetcode78 - Subsets"></a>0711 - Leetcode78 - Subsets</h1><blockquote><p>Given a set of <strong>distinct</strong> integers, <em>nums</em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>用recursive吧，因为不希望出现重复项，所以新加进来的数可以视为前一个subset 加上 一个新的数字，而这个新的数字是subdet最后一位数字往后的。所以可以用resurcive。</p><p>比如说 </p><ul><li>[] 是初始解，那么[] +[1], [] + [2], []+[3] 就是第一层解</li><li>[1] + [2], [1]+[3] 就要继续下去。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        sub = []</span><br><span class="line">        ans.append(sub)</span><br><span class="line">        self.newsub(sub, nums, <span class="number">0</span>, ans)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newsub</span>(<span class="params">self, sub, nums, i, ans</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            ans.append(sub + [nums[i]])</span><br><span class="line">            self.newsub(sub + [nums[i]], nums, i+<span class="number">1</span>, ans)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      </span><br></pre></td></tr></table></figure><h1 id="0708-3Sum"><a href="#0708-3Sum" class="headerlink" title="0708 - 3Sum"></a>0708 - 3Sum</h1><blockquote><p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note:</strong></p><p>The solution set must not contain duplicate triplets.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>先排序，再固定指针 i ，然后从这个指针向右的序列确定两个指针 left, right, 寻找nums[i] = -(nums[left]+nums[right])。</p><p>如果左右两指针相加大于  -(nums[left]+nums[right])，right -= 1, 否则 left+=1.如果相等就把者三个数的list放在ans中。</p><p><strong>注意！！！</strong></p><p>这个题直接这样写会超时，所以要考虑很多特殊的情况。</p><ol><li><p>if nums[i] &gt; 0, break 当最小值都大于零，右边的nums[left]和nums[right]肯定都大于零，就不可能存在三个数相加为0的情况；</p></li><li><p>判断是否有重复: if nums[left - 1] &gt; i and nums[left - 1] ==  nums[left]: 这时候left可以直接+1忽略</p><p>同理，可以跳过重复的右指针。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]: <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> left - <span class="number">1</span> &gt; i <span class="keyword">and</span> nums[left] == nums[left<span class="number">-1</span>]: </span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> right+<span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[right] == nums[right+<span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> nums[left] + nums[right] == -nums[i]:</span><br><span class="line">                    ans.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">elif</span> nums[left] + nums[right] &gt; -nums[i]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1 id="0707-Leetcode463-Island-Perimeter"><a href="#0707-Leetcode463-Island-Perimeter" class="headerlink" title="0707 - Leetcode463 - Island Perimeter"></a>0707 - Leetcode463 - Island Perimeter</h1><blockquote><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.</p><p>Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).</p><p>The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line"> [1,1,1,0],</span><br><span class="line"> [0,1,0,0],</span><br><span class="line"> [1,1,0,0]]</span><br><span class="line"></span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>很简单，遍历grid中的每一项，如果是1，那么他就会有4条边，然后减去临边也为1的数量，然后就可以得到小岛的周长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">islandPerimeter</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        row = <span class="built_in">len</span>(grid)</span><br><span class="line">        col = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        count1 = <span class="number">0</span></span><br><span class="line">        edge = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    count1 += <span class="number">1</span></span><br><span class="line">                    edge = edge + (self.countLand(grid, i+<span class="number">1</span>, j) +self.countLand(grid, i<span class="number">-1</span>, j)+self.countLand(grid, i, j+<span class="number">1</span>)+self.countLand(grid, i, j<span class="number">-1</span>))</span><br><span class="line">                    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>*count1 - edge</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countLand</span>(<span class="params">self, grid, i, j</span>):</span></span><br><span class="line">        land = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(grid) <span class="keyword">and</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>]):</span><br><span class="line">            land += grid[i][j]</span><br><span class="line">        <span class="keyword">return</span> land</span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode695-Max-Area-of-Island"><a href="#补充-Leetcode695-Max-Area-of-Island" class="headerlink" title="补充 - Leetcode695 - Max Area of Island"></a>补充 - Leetcode695 - Max Area of Island</h1><blockquote><p>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an <strong>island</strong> is a group of <code>1</code>‘s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p></blockquote><p>解题思路：</p><ol><li><p>DFS。寻找最大岛屿面积，遍历每一个点，然后从每一个点延伸开始寻找它周围的是1的点，遍历过的点改标记为0.</p><p>之前有一个题，也是遍历每一个点，然后遍历的时候改为-1，之后遍历完又换回来。这种是 解跟解之间独立的，比如是某条路径（我实在找不到那道题了），还要换回来因为可能此路不通，我们还要走下一条路。但是这种求面积的，包括数岛屿个数的题，我们在换了标记之后表示我们已经count了这个grid[i][j]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        max_area = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                max_area = <span class="built_in">max</span>(max_area, self.dfs(grid, i, j))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> max_area</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, grid, i, j</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] == <span class="number">0</span>: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        grid[i][j] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.dfs(grid, i+<span class="number">1</span>, j) + self.dfs(grid, i<span class="number">-1</span>, j) + self.dfs(grid, i, j+<span class="number">1</span>) + self.dfs(grid, i, j<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="0706-Leetcode66-Plus-One"><a href="#0706-Leetcode66-Plus-One" class="headerlink" title="0706 - Leetcode66 - Plus One"></a>0706 - Leetcode66 - Plus One</h1><blockquote><p>Given a <strong>non-empty</strong> array of digits representing a non-negative integer, plus one to the integer.</p><p>The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</p><p>You may assume the integer does not contain any leading zero, except the number 0 itself.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>硬做。这道题就是在问给出的list如果代表的是一个数字，那么这个数字加上1之后，得到的list会是什么样子。给出的例子都很简单，简直是迷惑人。因为有几种特殊的情况，一种是最后一位为9的时候，它加上1之后要进位的，另一种情况是最高位同样为9的时候，它加上一是要变多一位的。所以单纯对list里面的数字进行加1处理远远不够。 我一开始想的就是把给的list转化为数字，然后+1，然后再拆解成list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(digits):</span><br><span class="line">            num = <span class="number">10</span>*num + digits[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        num = num+<span class="number">1</span>    </span><br><span class="line">        plus = []</span><br><span class="line">        <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">            plus.append(num % <span class="number">10</span>)</span><br><span class="line">            num //= <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> plus[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><p>recursion</p><p>迭代去做考虑的因素就不需要分开考虑究竟最高位是不是9，那我们返回的值就是当我们所处的这一位是9的话，就把这个数字改换为0，然后对前面的数字进行+1处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type digits: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> digits[<span class="number">-1</span>] &lt; <span class="number">9</span>:</span><br><span class="line">            digits[<span class="number">-1</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> digits        </span><br><span class="line">        <span class="keyword">elif</span> digits[<span class="number">-1</span>] == <span class="number">9</span>:         </span><br><span class="line">            <span class="keyword">return</span> self.plusOne(digits[:<span class="number">-1</span>]) + [<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li></ol><h1 id="0705-Leetcode461-Hamming-Distance"><a href="#0705-Leetcode461-Hamming-Distance" class="headerlink" title="0705 - Leetcode461 - Hamming Distance"></a>0705 - Leetcode461 - Hamming Distance</h1><blockquote><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p><p><strong>Note:</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line"><span class="code">       ↑   ↑</span></span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>我一开始是想着移位运算有没有取最后一位然后取异或的，但是没想起来该怎么写。于是就用了最原始的求数字二进制的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span>(<span class="params">self, x, y</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">and</span> y == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            count += (x%<span class="number">2</span>) ^ (y%<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">            x = x // <span class="number">2</span></span><br><span class="line">            y = y // <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>后面查了一下确实有直接算二进制的：</p><p><code>bin(x)</code> 可以返回x的二进制表示形式，但是返回的值是一个string</p><p><code>int(x, 16)</code> 可以将16进制下的字符串类型x转化为一个十进制的int形式的数字</p><h1 id="补充-Leetcode477-Total-Hamming-Distance"><a href="#补充-Leetcode477-Total-Hamming-Distance" class="headerlink" title="补充 - Leetcode477 - Total Hamming Distance"></a>补充 - Leetcode477 - Total Hamming Distance</h1><blockquote><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Now your job is to find the total Hamming distance between all pairs of the given numbers.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: 4, 14, 2</span><br><span class="line"></span><br><span class="line">Output: 6</span><br><span class="line"></span><br><span class="line">Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just</span><br><span class="line">showing the four bits relevant in this case). So the answer will be:</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>和上面一题不同，这道题如果每两对都要计算一下hamming distance再相加的话，就会造成很多重复的计算。所以我是直接想用数学方法写的，没有用到算法的技巧。</p><p>假设我们的 list 中一共有 N 个数字，因为我们要求这些数字的二进制表示下的位数的差异，所以我们需要把这些数字都用0 1表示。那么对于这N个数字而言，拿出每两个数字然后逐位进行比较就相当于，对于每一位而言，我们把这N个0或1的数字拿出来，然后看看能有几个不一样。所以用到了排列组合的思想。</p><p>对于每一位而言，N个数字一共会有个 $2 \choose N$ 种结果，$ {2 \choose N } = {N-2 \choose N} = (N-1)*N$， 而在这一位上面，我们只有两种选择，要么0 要么1，所以我们再利用一个count list来统计一下每一位1的个数<code>count[i]</code>。最后对于每一位而言，两两数字不同的可能性就有 ${2 \choose N} - {2 \choose count[i]} - {2 \choose N-count[i]}$.</p><p>扫了一眼讨论区，哦，我好蠢，两两不同的可能性就是 $count[i] \times (N - count[i])$。大部分也是通过数学计算来解决这个问题的。</p><p><strong>又学了一招 <code>&quot;&#123;0:b&#125;&quot;.format(num)</code> 可以把num转化为二进制字符串</strong></p><p><code>print(&quot;bin: &#123;0:b&#125;, oct: &#123;0:o&#125;, hex: &#123;0:x&#125;&quot;.format(12))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">totalHammingDistance</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       :type nums: List[int]</span></span><br><span class="line"><span class="string">       :rtype: int</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       count = [<span class="number">0</span>] * <span class="number">32</span></span><br><span class="line">       <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">           i = <span class="number">0</span></span><br><span class="line">           <span class="keyword">while</span> num != <span class="number">0</span>:</span><br><span class="line">               count[i] += num % <span class="number">2</span></span><br><span class="line">               num /= <span class="number">2</span></span><br><span class="line">               i += <span class="number">1</span>                </span><br><span class="line">       N = <span class="built_in">len</span>(nums)</span><br><span class="line">       total_ham = <span class="number">0</span></span><br><span class="line">               </span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(count)):            </span><br><span class="line">           <span class="keyword">if</span> count[i] &gt; <span class="number">0</span>:                </span><br><span class="line">               total_ham  += N * (N - <span class="number">1</span>)/<span class="number">2</span> - count[i]*(count[i]<span class="number">-1</span>)/<span class="number">2</span> - (N - count[i])*(N - count[i] - <span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">               </span><br><span class="line">       <span class="keyword">return</span> total_ham</span><br></pre></td></tr></table></figure></li></ol><h1 id="0704-Leetcode264-Ugly-Number-II"><a href="#0704-Leetcode264-Ugly-Number-II" class="headerlink" title="0704 - Leetcode264 - Ugly Number II"></a>0704 - Leetcode264 - Ugly Number II</h1><blockquote><p>Write a program to find the <code>n</code>-th ugly number.</p><p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>. </p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>最小堆帮助排序：主要还是明确Ugly Number的定义吧，指的就是factor只有2，3，5的数字。那么就意味着我所有的数字只能是ugly number的乘积。所以就从1开始，之后所有的数字都是ugly number里面的数字 <em>2 </em>3 *5.</p><p>一开始想用动态规划，但这里存在一个排序的问题，第一个数字乘 2 3 5和第二个数字乘2 3 5，哪个应该放在哪个后面。但后来想到用min heap这个结构，会把最小的放在上面，每次我们pop出来最小的数字放在我们的sorted ugly number lsit中，然后再把它乘以2 3 5的数字放进我们的min heap中，就行了。如果pop出来的数字已经在我们的sorted ugly number里面了，那我们就跳过这个数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sorted_ugly = []</span><br><span class="line">        heap = [<span class="number">1</span>]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(sorted_ugly) &lt; n:            </span><br><span class="line">            next_ugly = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> next_ugly <span class="keyword">not</span> <span class="keyword">in</span> sorted_ugly:</span><br><span class="line">                sorted_ugly.append(next_ugly)</span><br><span class="line">                heapq.heappush(heap, next_ugly*<span class="number">2</span>)</span><br><span class="line">                heapq.heappush(heap, next_ugly*<span class="number">3</span>)</span><br><span class="line">                heapq.heappush(heap, next_ugly*<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> sorted_ugly[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><p>动态规划</p><p>把2 3 5需要乘的数字表示为指针，然后依次升高，进行排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type n: int</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [<span class="number">1</span>]</span><br><span class="line">    pointer2 = <span class="number">0</span></span><br><span class="line">    pointer3 = <span class="number">0</span></span><br><span class="line">    pointer5 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(dp) &lt; n:</span><br><span class="line">        dp = dp + [<span class="built_in">min</span>(dp[pointer2]*<span class="number">2</span>, dp[pointer3]*<span class="number">3</span>, dp[pointer5]*<span class="number">5</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">-1</span>] == dp[pointer2]*<span class="number">2</span>:</span><br><span class="line">            pointer2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">-1</span>] == dp[pointer3]*<span class="number">3</span>:</span><br><span class="line">            pointer3 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[<span class="number">-1</span>] == dp[pointer5]*<span class="number">5</span>:</span><br><span class="line">            pointer5 += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol><h1 id="补充-Leetcode263-Ugly-Number"><a href="#补充-Leetcode263-Ugly-Number" class="headerlink" title="补充 - Leetcode263 - Ugly Number"></a>补充 - Leetcode263 - Ugly Number</h1><blockquote><p>Write a program to check whether a given number is an ugly number.</p><p>Ugly numbers are <strong>positive numbers</strong> whose prime factors only include <code>2, 3, 5</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 6 = 2 × 3</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>更直接一点，只用循环除以2 3 5 就可以了。注意小于0的数字和 =0 的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isUgly</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> num != <span class="number">1</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num = num //<span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> num%<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                num = num//<span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> num%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num = num//<span class="number">5</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="0703-Leetcode957-Prison-Cells-After-N-days"><a href="#0703-Leetcode957-Prison-Cells-After-N-days" class="headerlink" title="0703 - Leetcode957 - Prison Cells After N days"></a>0703 - Leetcode957 - Prison Cells After N days</h1><blockquote><p>There are 8 prison cells in a row, and each cell is either occupied or vacant.</p><p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p><ul><li>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.</li><li>Otherwise, it becomes vacant.</li></ul><p>(Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.)</p><p>We describe the current state of the prison in the following way: <code>cells[i] == 1</code> if the <code>i</code>-th cell is occupied, else <code>cells[i] == 0</code>.</p><p>Given the initial state of the prison, return the state of the prison after <code>N</code> days (and <code>N</code> such changes described above.)</p></blockquote><p>解题思路：</p><ol><li><p>规律总结，我是总结规律来的。因为如果写一个方程然后运行N次感觉时间复杂度会比较高。总结规律之后，14变换为一轮回，然后求余数就可以了。但是这个应该是有更底层的解释，为什么14个一个轮回。还有看到的规律是，几次之后，后面的模式和前面相比是前半部分和后半部分调换了位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(1), Space: O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prisonAfterNDays</span>(<span class="params">self, cells, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type cells: List[int]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>: <span class="keyword">return</span> cells</span><br><span class="line">        temp = [<span class="number">0</span>]*<span class="number">8</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cells) - <span class="number">1</span>):                </span><br><span class="line">                temp[i] = <span class="number">1</span> - cells[i<span class="number">-1</span>] ^ cells[i+<span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        cells = temp</span><br><span class="line">        </span><br><span class="line">        re = (N - <span class="number">1</span>) % <span class="number">14</span></span><br><span class="line">        <span class="keyword">while</span> re &gt; <span class="number">0</span>:</span><br><span class="line">            temp = [<span class="number">0</span>]*<span class="number">8</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cells) - <span class="number">1</span>):                </span><br><span class="line">                temp[i] = <span class="number">1</span> - cells[i<span class="number">-1</span>] ^ cells[i+<span class="number">1</span>]               </span><br><span class="line">            cells[<span class="number">1</span>:<span class="number">8</span>] = temp[<span class="number">1</span>:<span class="number">8</span>]            </span><br><span class="line">            re -= <span class="number">1</span>           </span><br><span class="line">        <span class="keyword">return</span> cells</span><br><span class="line">     </span><br></pre></td></tr></table></figure></li><li><p>常规做法：将pattern保存在dictionary中，然后看几个一循环。（因为有的时候可能循环周期不同</p><p>需要注意的是保存在字典里的数字是我们接下来要找的余数，余数是从 0 到 T-1（T为周期），所以N在计算的时候需要做-1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(1) Space: O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prisonAfterNDays</span>(<span class="params">self, cells, N</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type cells: List[int]</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pattern_dict = &#123;&#125;</span><br><span class="line">        <span class="comment"># cells = self.nextPattern(cells)</span></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            cells = self.nextPattern(cells)</span><br><span class="line">            <span class="keyword">if</span> cells <span class="keyword">in</span> pattern_dict.values():</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pattern_dict[n<span class="number">-1</span>] = cells    </span><br><span class="line">        T = n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pattern_dict[(N<span class="number">-1</span>) % T]</span><br></pre></td></tr></table></figure></li></ol><h1 id="0702-Leetcode107-Binary-Tree-Level-Order-Traversal-II-（104同理）"><a href="#0702-Leetcode107-Binary-Tree-Level-Order-Traversal-II-（104同理）" class="headerlink" title="0702 - Leetcode107 - Binary Tree Level Order Traversal II （104同理）"></a>0702 - Leetcode107 - Binary Tree Level Order Traversal II （104同理）</h1><blockquote><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its bottom-up level order traversal as:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路:</p><p>普通的BFS每层拿出，遍历，再将每层的left right放入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        queue = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            nodes = []</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">                nodes.append(queue.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="comment"># print(nodes)</span></span><br><span class="line">            tmp = [n.val <span class="keyword">for</span> n <span class="keyword">in</span> nodes]</span><br><span class="line">            ans.append(tmp)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nodes:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    queue.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:  </span><br><span class="line">                    queue.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br><span class="line">            </span><br></pre></td></tr></table></figure><p>上述如果返回的是 <code>ans</code> 那就是不bottom up的 level traverse 遍历二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 学到了deque 读（deck）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">deque.pop()</span><br><span class="line">deque.popleft() <span class="comment"># 和append组合相当于queue的FIFO</span></span><br></pre></td></tr></table></figure><h1 id="0701-Leetcode441-Arranging-coins"><a href="#0701-Leetcode441-Arranging-coins" class="headerlink" title="0701 - Leetcode441 - Arranging coins"></a>0701 - Leetcode441 - Arranging coins</h1><blockquote><p>You have a total of <em>n</em> coins that you want to form in a staircase shape, where every <em>k</em>-th row must have exactly <em>k</em> coins.</p><p>Given <em>n</em>, find the total number of <strong>full</strong> staircase rows that can be formed.</p><p><em>n</em> is a non-negative integer and fits within the range of a 32-bit signed integer.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = 5</span><br><span class="line"></span><br><span class="line">The coins can form the following rows:</span><br><span class="line">¤</span><br><span class="line">¤ ¤</span><br><span class="line">¤ ¤</span><br><span class="line"></span><br><span class="line">Because the 3rd row is incomplete, we return 2.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>看到这道题首先想到的是斐波那契数列，因而想到了用动态规划来写。这道题不是斐波那切数列啊！就是看到这个排列想到了。如果用动态规划写的话：</p><ul><li>dp[i] 表示的就是当第i行排满之后，总共需要几个coin</li><li>状态转移方程 dp[i] = dp[i-1] + i</li><li>实质上也是等差数列求和：求一个 <code>int(k)</code> 使得 $\frac{k(k+1)}{2} &lt;= n$， 得出的解是 $k = \frac{-1+\sqrt{1+8n}}{2} = \sqrt{2n + 0.25} - 0.5$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(sqrt(n)) Space: O(sqrt(n))</span></span><br><span class="line"><span class="comment"># 这样写会TLE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrangeCoins</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = []</span><br><span class="line">        dp = dp+[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;= dp[<span class="number">-1</span>]:</span><br><span class="line">            dp = dp + [count + dp[<span class="number">-1</span>]]</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count - <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>写的时候直接用n减去每次的循环序号（i.e. 第一次减去1，第二次减去2）当n小于0的时候就跳出循环，返回循环的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Time: O(sqrt(n))(?是这样吗) Space: O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrangeCoins</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n &gt;= <span class="number">0</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            n -= count</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count - <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>看了别人写的之后还有Binary Search. 二叉树的时候更新左右两个端点总是会忽略的一个问题是，如果你要保左端点，那在算中值的时候需要+1，这样才能保证不陷入死循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrangeCoins</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = n</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="comment"># print(left, right)</span></span><br><span class="line">            mid = (left + right + <span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid*(mid+<span class="number">1</span>)/<span class="number">2</span> &lt; n: </span><br><span class="line">                left = mid </span><br><span class="line">            <span class="keyword">if</span> mid*(mid+<span class="number">1</span>)/<span class="number">2</span> &gt; n: </span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> mid*(mid+<span class="number">1</span>)/<span class="number">2</span> == n: </span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> left </span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【LeetCode】- July Challenge&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc441&quot;&gt;0701 - Leetcode441 - Arranging coins - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc107&quot;&gt;0702 - Leetcod</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm | Binary Tree</title>
    <link href="http://yoursite.com/2020/06/23/Algorithm-Binary-Tree/"/>
    <id>http://yoursite.com/2020/06/23/Algorithm-Binary-Tree/</id>
    <published>2020-06-23T20:56:13.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考网页： <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html">https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html</a></p><h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1><p>我们将Linked Data Structure的结构拓展，使得一个节点可以和两个node相连接。二叉树的结构由节点构成，有左节点和右节点并且和它本身的值。最顶层的node被称为根root</p><p>每一个node（包括root在内）都只和另一个node相连，它们之间的连接成为edge，而该node被称为parent。另一方面来讲，一个node可以和任意多个node相连，每一个node都是他的children（就是在说一个node可以有多个children但是只能有一个parent），没有children的node被称作leaves， 处在中间的node都叫内部节点，拥有相同parent的node被称为siblings.</p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="前序遍历-preorder"><a href="#前序遍历-preorder" class="headerlink" title="前序遍历 preorder"></a>前序遍历 preorder</h2><p>遍历顺序是：parent-left-right</p><ul><li><p>给定Binary Tree， 求前序遍历得到的数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Recursive</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  ans = []</span><br><span class="line">  self.helper(root, ans)</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, ans</span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root:</span><br><span class="line">    ans.append(root.val)</span><br><span class="line">    self.helper(root.left, ans)</span><br><span class="line">    self.helper(root.right, ans)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Iterative</span></span><br><span class="line"></span><br><span class="line">    stack = []</span><br><span class="line">    ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> root <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">while</span> root:</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        stack.append(root.right)</span><br><span class="line">        root = root.left</span><br><span class="line">      root = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="中序遍历-inorder"><a href="#中序遍历-inorder" class="headerlink" title="中序遍历 inorder"></a>中序遍历 inorder</h2><p>遍历顺序是：left-parent-left</p><ul><li><p>给定Binary Tree， 求中序遍历得到的数值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Recursive</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  ans = []</span><br><span class="line">  </span><br><span class="line">  self.helper(root, ans)</span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, ans</span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root:</span><br><span class="line">    self.helper(root.left)</span><br><span class="line">    ans.append(root.val)</span><br><span class="line">    self.helper(root.right)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Iteration</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  ans, stack = [], []</span><br><span class="line">  <span class="keyword">while</span> root <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> root:</span><br><span class="line">      stack.append(root)</span><br><span class="line">      root = root.left</span><br><span class="line">      </span><br><span class="line">    root = stack.pop()</span><br><span class="line">    ans.append(root.val)</span><br><span class="line">    root = root.right</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h2 id="后序遍历-postorder"><a href="#后序遍历-postorder" class="headerlink" title="后序遍历 postorder"></a>后序遍历 postorder</h2><p>遍历顺序是：left-right-parent</p><ul><li><p>给定Binary Tree，求后序遍历输出的数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Recursive</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  </span><br><span class="line">  ans = []</span><br><span class="line">  <span class="keyword">return</span> self.helper(self, root, ans)</span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">self, root, ans</span>):</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> root:</span><br><span class="line">    self.helper(root.left)</span><br><span class="line">    self.helper(root.right)</span><br><span class="line">    ans.append(root.val)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Iterative</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans, stack = [], [root]</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> root:</span><br><span class="line"></span><br><span class="line">            root = stack.pop()</span><br><span class="line">            ans.append(root.val)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append(root.left)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append(root.right)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考网页： &lt;a href=&quot;https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/trees.html&quot;&gt;https://www.cs.cmu.edu/~adamchik/15-121/lectures/Trees/</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
    <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读 | SMPL: A Skinned Multi-Person Linear Model</title>
    <link href="http://yoursite.com/2020/06/12/PaperReading-SMPL-A-Skinned-Multi-Person-Linear-Model/"/>
    <id>http://yoursite.com/2020/06/12/PaperReading-SMPL-A-Skinned-Multi-Person-Linear-Model/</id>
    <published>2020-06-12T20:40:44.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>论文题目： <a href="http://files.is.tue.mpg.de/black/papers/SMPL2015.pdf">SMPL: A Skinned Multi-Person Linear Model</a></li><li>论文作者：\ $Matthew Loper, Naureen Mahmood, Javier Romero, Gerard Pons-Moll,  Michael J. Black$</li></ul><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们学习了一种描述人体形状和姿态变换模型，这种模型应用了类似的资源并且较之前的模型更为精确。我们的Skinned Multi-Person Linear （SMPL）模型是基于skinned vertex的模型，可以准确得描述人的形状和姿态。模型的参数从包括了静态姿态模板，blend weight，基于姿态的blend shape还有基于人个体的blend shape还有一个由人体模型中的顶点到骨骼joint的regressor中学习。（这些专业的名词太多了，一会儿也会说到）。和之前模型不一样的是，pose-dependent blend shape是姿态旋转矩阵的线性方程。这个 简单的模型可以让我们在大量的对齐人体不同姿态中学习。 SMPL模型的准确度比SCAPE要高，并且因为SMPL模型是基于blend skinning的，所以在渲染engine中也可以使用。</p><a id="more"></a><h1 id="模型构成"><a href="#模型构成" class="headerlink" title="模型构成"></a>模型构成</h1><p>我们的SMPL模型主要在下图中有所说明。<img src="../images/Screen%20Shot%202020-06-13%20at%2017.25.26.png" alt="Screen Shot 2020-06-13 at 17.25.26"></p><p>和SCAPE模型相似，SMPL模型也是将身体拆解成了identity-based shape，也就是和人相关的shape（不同人不同形状）和非刚性的pose-dependent shape，也就是取决于姿态的shape。和SCAPE不同的是，这里用到的是运用纠正混合的vertex-based skinning 方法。</p><p>一个单独的混合形状（blend shape）</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;论文题目： &lt;a href=&quot;http://files.is.tue.mpg.de/black/papers/SMPL2015.pdf&quot;&gt;SMPL: A Skinned Multi-Person Linear Model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;论文作者：\ $Matthew Loper, Naureen Mahmood, Javier Romero, Gerard Pons-Moll,  Michael J. Black$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;我们学习了一种描述人体形状和姿态变换模型，这种模型应用了类似的资源并且较之前的模型更为精确。我们的Skinned Multi-Person Linear （SMPL）模型是基于skinned vertex的模型，可以准确得描述人的形状和姿态。模型的参数从包括了静态姿态模板，blend weight，基于姿态的blend shape还有基于人个体的blend shape还有一个由人体模型中的顶点到骨骼joint的regressor中学习。（这些专业的名词太多了，一会儿也会说到）。和之前模型不一样的是，pose-dependent blend shape是姿态旋转矩阵的线性方程。这个 简单的模型可以让我们在大量的对齐人体不同姿态中学习。 SMPL模型的准确度比SCAPE要高，并且因为SMPL模型是基于blend skinning的，所以在渲染engine中也可以使用。&lt;/p&gt;</summary>
    
    
    
    <category term="论文阅读" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="3D" scheme="http://yoursite.com/tags/3D/"/>
    
    <category term="HumanBody" scheme="http://yoursite.com/tags/HumanBody/"/>
    
    <category term="ArticultatedHumanBody" scheme="http://yoursite.com/tags/ArticultatedHumanBody/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm | Sorting</title>
    <link href="http://yoursite.com/2020/06/08/Algorithm-Sorting/"/>
    <id>http://yoursite.com/2020/06/08/Algorithm-Sorting/</id>
    <published>2020-06-09T01:52:40.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法</p><h1 id="Quick-Sort-快速排序"><a href="#Quick-Sort-快速排序" class="headerlink" title="Quick Sort - 快速排序"></a>Quick Sort - 快速排序</h1><p>快排的主要思想是divide and conquer，是把一个大问题划分成几个小问题然后再合并在一起的方法。</p><p>核心问题就是找到一个pivot的位置，使得pivot左边的数字都小于pivot，而右边的数字都大于pivot，这样pivot的位置就定了，然后我们再分别对两边的数字再进行：寻找pivot - 找左边 - 找右边。</p><p>这种循环进行的操作的好处在于，我们找到的pivot的位置是正确的，然后在每个小问题中，不断地实施这个操作，就可以让每个数字找到合适自己的位置。 </p><p>假设我们有一个可以帮助我们寻找pivot的函数 Partition，那么排序的过程就可以写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> low &lt; high:</span><br><span class="line">        pivot = partition(arr, low, high)</span><br><span class="line"></span><br><span class="line">        quicksort(arr, low, pivot<span class="number">-1</span>)</span><br><span class="line">        quicksort(arr, pivot+<span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>返回pivot的位置可以帮助我们固定pivot，更好得对pivot之前和之后个数组进行操作。</p><p>那么问题是，现在如何定义函数Partition?</p><p>函数Partition的主要作用是，将输入array中的某一个数定义为pivot，并且确定它在array中的位置。我们一般选取array最后一个值作为pivot，然后将这个pivot放在正确的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">arr, low, high</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    mid = (low + high)//<span class="number">2</span></span><br><span class="line">    arr[mid], arr[<span class="number">-1</span>] = arr[<span class="number">-1</span>], arr[mid]</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; arr[<span class="number">-1</span>]:</span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            <span class="comment"># print(arr)</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    arr[j], arr[<span class="number">-1</span>] = arr[<span class="number">-1</span>], arr[j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure><h1 id="Bubble-Sort-冒泡排序"><a href="#Bubble-Sort-冒泡排序" class="headerlink" title="Bubble Sort - 冒泡排序"></a>Bubble Sort - 冒泡排序</h1><p>冒泡排序的核心思想在于两两比较数字之间的大小然后将最大的移动到最后。</p><p>第一步bul</p><p>时间复杂度 ： O(n^2)</p><p>空间复杂度：O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubblesort</span>(<span class="params">arr</span>):</span></span><br><span class="line">    k = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[i<span class="number">-1</span>]:</span><br><span class="line">                arr[i], arr[i<span class="number">-1</span>] = arr[i<span class="number">-1</span>], arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>算是比较简单明白的排序，注意一点的是 <code>while k &gt; 0</code> 和后面的<code>k -= 0</code> 同样可以用一句 <code>for _ in range(len(arr))</code> 代替，这样时间复杂度会更高。之前用while是考虑到后面比较大的数字已经放在最后就不需要考虑了。时间复杂度是 $O(n^2)$</p><h1 id="Merge-Sort-归并排序"><a href="#Merge-Sort-归并排序" class="headerlink" title="Merge Sort - 归并排序"></a>Merge Sort - 归并排序</h1><p>归并排序的方法主要思想也是divide and conquer，既然如此，我们需要把大的排序分解成小的序列，然后排序之后再合并在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="comment"># print(left, right)</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    merge_arr = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(left) <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            merge_arr.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            merge_arr.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="built_in">len</span>(left):</span><br><span class="line">        merge_arr = merge_arr + right[j:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        merge_arr = merge_arr + left[i:]</span><br><span class="line">    print(merge_arr)</span><br><span class="line">    <span class="keyword">return</span> merge_arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">arr, start, end</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start == end:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[start:end+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    mid = (start + end)//<span class="number">2</span></span><br><span class="line">    left = mergeSort(arr, start, mid)</span><br><span class="line">    right = mergeSort(arr, mid + <span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line">    merge_arr = merge(left, right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_arr</span><br></pre></td></tr></table></figure><h1 id="Insertion-Sort-插入排序"><a href="#Insertion-Sort-插入排序" class="headerlink" title="Insertion Sort - 插入排序"></a>Insertion Sort - 插入排序</h1><p>插入排序的思想是将未排序的值插入到之前的已经排序的数列中去。</p><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionsort</span>(<span class="params">arr</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        print(arr)</span><br><span class="line">        k = i</span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[k] &lt; arr[k - <span class="number">1</span>]:</span><br><span class="line">                arr[k], arr[k<span class="number">-1</span>] = arr[k<span class="number">-1</span>], arr[k]</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;排序算法&lt;/p&gt;
&lt;h1 id=&quot;Quick-Sort-快速排序&quot;&gt;&lt;a href=&quot;#Quick-Sort-快速排序&quot; class=&quot;headerlink&quot; title=&quot;Quick Sort - 快速排序&quot;&gt;&lt;/a&gt;Quick Sort - 快速排序&lt;/h1&gt;&lt;p&gt;快排</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm | LeetCode - June Challenge</title>
    <link href="http://yoursite.com/2020/06/06/Algorithm-Leetcode-June%20Challenge/"/>
    <id>http://yoursite.com/2020/06/06/Algorithm-Leetcode-June%20Challenge/</id>
    <published>2020-06-07T03:31:47.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>【LeetCode】- June Challenge</p><p><a href="#lc1029">0606 - Leetcode1029 - Two City Scheduling - Easy</a></p><p><a href="#lc518">0607 - Leetcode518 - Coin Change 2 - Medium</a></p><p><a href="#lc322">补充 - Leetcode322 - Coin Change - Medium</a></p><p><a href="#lc231">0608 - Leetcode231-Power Of Two - Easy</a></p><p><a href="#lc392">0609 - Leetcode392 - Is Subsequence - Easy</a></p><p><a href="#lc115">补充 - Leetcode115 - Distinct Subsequence - Hard</a></p><p><a href="#lc35">0610 - Leetcode35 - Search Insert Position - Easy</a></p><p><a href="#lc75">0611 - Leetcode75 - Sorting Colors - Medium</a></p><p><a href="#lc380">0612 - Leetcode380 - Insert Delete GetRandom O(1) - Medium</a></p><p><a href="#lc368">0613 - Leetcode368 - Largest Divisible Subset - Medium</a></p><p><a href="#lc300">补充 - Leetcode300 - Longest Increasing Subsequence - Medium</a></p><p><a href="#lc787">0614 - Leetcode787 - Cheapest Flights within K stops - Medium</a></p><p><a href="#lc700">0615 - Leetcode700 - Search in a Binary Search Tree - Easy</a></p><p><a href="#lc468">0616 - Leetcode468 - Validate IP Address - Medium</a></p><p><a href="#lc130">0617 - Leetcode130 - Surrounded Regions - Medium</a></p><p><a href="#lc200">补充 - Leetcode200 - Number of Islands - Medium</a></p><p><a href="#lc547">补充 - Leetcode547 - Friend Circles - Medium</a></p><p><a href="#lc275">0618 - Leetcode275 - H-index II - Medium</a></p><p><a href="#lc1044">0619 - Leetcode1044 - Longest Duplicate Substring - Hard</a></p><p><a href="#lc60">0620 - Leetcode60 - Permutation Sequence - Medium</a></p><p><a href="#lc31">补充 - Leetcode31 - Next Permutation - Medium</a></p><p><a href="#lc46">补充 - Leetcode46 - Permutations - Medium</a></p><p><a href="#lc174">0621 - Leetcode174 - Dungeon Games - Hard</a></p><p><a href="#lc137">0622 - Leetcode137 - Single Number II - Medium</a></p><p><a href="#lc136">补充 - Leetcode136 - Single Number I - Easy</a></p><p><a href="#lc260">补充 - Leetcode260 - Single Number III - Medium</a></p><p><a href="#lc222">0623 - Leetcode222 - Count Complete Tree Node - Medium</a></p><p><a href="#lc96">0624 - Leetcode96 - Unique Binary Search Trees - Medium</a></p><p><a href="#lc95">补充 - Leetcode95 -Unique Binary Search Trre II - Medium</a></p><p><a href="#lc287">0625 - Leetcode287 - Find the Duplicate Number - Medium</a></p><p><a href="#lc142">补充 - Leetcode142 - Linked List Cycle II - Medium</a></p><p><a href="#lc129">0626 - Leetcode129 - Sum Root to Leaf Number - Medium</a></p><p><a href="#lc279">0627 - Leetcode279 - Perfect squares - Medium</a></p><p><a href="#lc322">0628 - Leetcode322 - Reconstruct Itenerary - Medium</a></p><p><a href="#lc62">0629 - Leetcode62 - Unique Paths - Medium</a></p><p><a href="#lc63">补充 - Leetcode63 - Unique Paths II - Medium</a></p><p><a href="#lc212">0630 - Leetcode212 - Word Search II - Hard</a></p><p><a href="#lc74">补充 - Leetcode79 - Word Search I - Medium</a></p><a id="more"></a><p>-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</p><h1 id="0630-Leetcode79-Word-Search-II"><a href="#0630-Leetcode79-Word-Search-II" class="headerlink" title="0630 - Leetcode79 - Word Search II"></a>0630 - Leetcode79 - Word Search II</h1><blockquote><p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p><p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">board = [</span><br><span class="line">  [&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;n&#x27;],</span><br><span class="line">  [&#x27;e&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;e&#x27;],</span><br><span class="line">  [&#x27;i&#x27;,&#x27;h&#x27;,&#x27;k&#x27;,&#x27;r&#x27;],</span><br><span class="line">  [&#x27;i&#x27;,&#x27;f&#x27;,&#x27;l&#x27;,&#x27;v&#x27;]</span><br><span class="line">]</span><br><span class="line">words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line"></span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>DFS ： 纯DFS就和后面word search I 是一样的，只不过这里给出了一个list的单词，我们需要针对这个list里面所有的单词来找。这个方法刚才在python里面尝试是超过时间限制的。那么看一下第二种</p></li><li><p>DFS+Trie：字典树的好处在于，如果我们有很多单词的前缀都一样而且特别长，字典树可以帮我们在board里面只寻找一次。</p><p>首先要知道如何构建字典树。</p><ul><li>字典树首先是一个有很多level的树，且每个level的branch的数量都是26（对于单词来说）。</li><li>字典树需要具备的方法是插入单词和查找单词。</li><li>字典树中每一个节点需要是一个dict 且 需要具备的性质是知道自己是否为一个单词。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Build Trie</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)</span><br><span class="line">        self.isword = <span class="literal">False</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        </span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            start = start.children[w]</span><br><span class="line">        </span><br><span class="line">        start.isword = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            start = start.children.get(w)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> start:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start.isword</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span>(<span class="params">self, board, words</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        trie = Trie()</span><br><span class="line">        node = trie.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(w)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, node, <span class="string">&quot;&quot;</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, board, i, j, node, path, ans</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.isword:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            node.isword = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        tmp = board[i][j]</span><br><span class="line"></span><br><span class="line">        node = node.children.get(tmp)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.dfs(board, i+<span class="number">1</span>, j, node, path+tmp, ans)</span><br><span class="line">        self.dfs(board, i<span class="number">-1</span>, j, node, path+tmp, ans)</span><br><span class="line">        self.dfs(board, i, j+<span class="number">1</span>, node, path+tmp, ans)</span><br><span class="line">        self.dfs(board, i, j<span class="number">-1</span>, node, path+tmp, ans)</span><br><span class="line"></span><br><span class="line">        board[i][j] = tmp</span><br></pre></td></tr></table></figure></li></ol><h1 id="0629-Leetcode62-Unique-Paths"><a href="#0629-Leetcode62-Unique-Paths" class="headerlink" title="0629 - Leetcode62 - Unique Paths"></a>0629 - Leetcode62 - Unique Paths</h1><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p></blockquote><p>解题思路：</p><p>老动态规划题了，很直接的想法，因为一个点只能由它上面一个点或者左边的点到达，那么我们定义dp表示到每个点一共有几条路径。</p><ul><li>定义动态规划矩阵：dp[i][j] 表示到达点 (i,j) 有几条unique的路径</li><li>状态转移方程： dp[i][j] = dp[i-1][j] +  dp[i][j-1]</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m) ]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode63-Unique-Paths-II"><a href="#补充-Leetcode63-Unique-Paths-II" class="headerlink" title="补充 - Leetcode63 - Unique Paths II"></a>补充 - Leetcode63 - Unique Paths II</h1><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p></blockquote><p>解题思路：</p><p>考虑障碍，有障碍的地方就设为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> * (<span class="number">1</span> - obstacleGrid[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] * (<span class="number">1</span> - obstacleGrid[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] * (<span class="number">1</span> - obstacleGrid[<span class="number">0</span>][j])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]) * (<span class="number">1</span> - obstacleGrid[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="0628-Leetcode322-Reconstruct-Itenerary"><a href="#0628-Leetcode322-Reconstruct-Itenerary" class="headerlink" title="0628 - Leetcode322 - Reconstruct Itenerary"></a>0628 - Leetcode322 - Reconstruct Itenerary</h1><blockquote><p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p><p><strong>Note:</strong></p><ol><li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li><li>All airports are represented by three capital letters (IATA code).</li><li>You may assume all tickets form at least one valid itinerary.</li><li>One must use all the tickets once and only once.</li></ol><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路</p><p>DFS，试探走路。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span>(<span class="params">self, tickets</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type tickets: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        paths = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        tickets.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> d, a <span class="keyword">in</span> tickets:</span><br><span class="line">            paths[d].append(a)</span><br><span class="line">            </span><br><span class="line">        self.dfs(<span class="string">&#x27;JFK&#x27;</span>, res, paths)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, d, res, paths</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res.append(d)</span></span><br><span class="line">        arrivals = paths[d]</span><br><span class="line">        <span class="keyword">while</span> arrivals:</span><br><span class="line">            self.dfs(arrivals.pop(), res, paths)</span><br><span class="line">            </span><br><span class="line">        res.append(d)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="0627-Leetcode279-Perfect-squares"><a href="#0627-Leetcode279-Perfect-squares" class="headerlink" title="0627 - Leetcode279 - Perfect squares"></a>0627 - Leetcode279 - Perfect squares</h1><blockquote><p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>动态规划。首先想到的就是动态规划，因为这道题和换零钱那道题太像了。但是做题的时候我不太能想起来换钱那道题是怎么做的了，就只记得换钱那道题考虑的是每一次，我这个1/2/5元的面值要不要参与其中。</p><p>所以这个题也差不多，刚开始的时候我想到的dp[i]是拥有i个square number的时候，可能组成的和的个数，这么一想的话，就有点像dfs了。所以我又换了个角度想了一下，dp[i]定义为：当和为i的时候，使用的最少的sqaure number有几个。</p><ul><li>dp矩阵的含义：当和为i的时候，使用的最少的sqaure number有几个</li><li>状态转移方程： dp[i] = min(dp[i], dp[i-square_number] + 1)。状态转移方程这里说的是，我们dp[i]使用的square number的个数可以由 dp[i - square number]使用的个数 + 1得到。</li><li>我一开始是循环整数将所有可能的（平方小于等于n）的数都找了一遍，然后存储起来，但是这样的话时间复杂度超过了。所以这里直接用 <code>range(1, int(n**0.5)+1)</code>来代替。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>([dp[i - k**<span class="number">2</span>] + <span class="number">1</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>)])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li><p>DFS</p><p>DFS 的思路也很好想到，就是你冲着一个数字一直选，直到达到想要的和n，然后返回这条路径用了几个square number，如果达到的和超过了n那么这条路径放弃，最后选出最短路径。</p></li></ol><h1 id="0626-Leetcode127-Sum-Root-to-Leaf-Number"><a href="#0626-Leetcode127-Sum-Root-to-Leaf-Number" class="headerlink" title="0626 - Leetcode127 - Sum Root to Leaf Number"></a>0626 - Leetcode127 - Sum Root to Leaf Number</h1><blockquote><p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p><p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p><p>Find the total sum of all root-to-leaf numbers.</p><p><strong>Note:</strong> A leaf is a node with no children.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line"><span class="code">    4</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  9   0</span></span><br><span class="line"><span class="code"> / \</span></span><br><span class="line"><span class="code">5   1</span></span><br><span class="line"><span class="code">Output: 1026</span></span><br><span class="line"><span class="code">Explanation:</span></span><br><span class="line"><span class="code">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span></span><br><span class="line"><span class="code">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span></span><br><span class="line"><span class="code">The root-to-leaf path 4-&gt;0 represents the number 40.</span></span><br><span class="line"><span class="code">Therefore, sum = 495 + 491 + 40 = 1026.</span></span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>Recursive：</p><p>我是用recursive写的，主要思路是尝试找到每一个leaf. 如果一个节点的左右子节点都是none，那么这个节点就是leaf， 遇到了leaf之后，我们才能把它加到总结果上面。可以有两个方案，一个是将这些root-leaf的数字保存在list里面，然后最后返回list的和，另一个是直接用累加来记录。</p><p><strong>需要注意的是</strong> 在做累加的时候，累加的参量一定是self.ans内部的变化量，不然再没有返回值的情况下，普通的变量是不会变化的。但是如果是都放在list里面，这个是可以的，可以将他们都保存起来，list在递归的过程中是一直变化的。这里的例子是按照path写的，因为可以提供更多的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.dfs(root, count, ans)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ans)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, count</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line">            ans.append(count)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line">            self.dfs(root.left, count, ans)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line">            self.dfs(root.right, count, ans)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                    </span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line"></span><br><span class="line">            self.dfs(root.left, count, ans)</span><br><span class="line">            self.dfs(root.right, count, ans)</span><br></pre></td></tr></table></figure></li><li><p>dfs+stack</p><p>这个思路是stack的顺序，然后改变每一个node的值为：到该点为止的累加值。</p><p>首先需要拿出root，然后放入stack中的数字是root的左右子节点，但是左右子节点对应的val的值分别存入的是 root.val*10 + root.right.val 和 root.val*10 + root.left.val,这样一直往stack里面放数字，如果左右子节点均为空，那么就用ans + 该点的val，如果左右子节点其中有一个为空，也不用管，直接return就可以。循环一直持续，直到stack中没有存储值。</p><p>（并没有改变树本身，而是在存在stack里面之后才改变了每个节点对应的value的值。）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        stack = [(root, root.val)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line"></span><br><span class="line">            root, val = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line"></span><br><span class="line">                res += val</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append((root.right, val*<span class="number">10</span> + root.right.val))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append((root.left, val*<span class="number">10</span> + root.left.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><h1 id="0625-Leetcode287-Find-the-Duplicate-Number"><a href="#0625-Leetcode287-Find-the-Duplicate-Number" class="headerlink" title="0625 - Leetcode287 - Find the Duplicate Number"></a>0625 - Leetcode287 - Find the Duplicate Number</h1><blockquote><p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>我一开始想的都太肤浅了，这道题的要求是时间复杂度不大于 $O(n^2)$, 空间复杂度为$O(1)$。 如果你普通得把见过一次的数字存在一个list里面，然后遍历整个序列的话，时间复杂度没超标但是空间复杂度超标了。</p><p>还有一种方法是可以用set，将nums进行set处理，然后nums和set过的nums求和做差，然后再除以两个nums的长度差。这种算法不知道算不算改变原有的nums，但同样也可以pass。</p><p>然后就来看看根正苗红的做法，可以用binary search来做。这里值得注意的是，题目中提到的，我们的nums的长度为n+1而nums中的数字都处于[1, …, n]。我们利用二分法查找来看多出来的这个duplicate数字究竟在哪里。</p><ul><li>首先左右两端的端点定下来，然后寻找中间的数字。</li><li>之后查看nums中，小于等于中间这个数nums[mid]的数字个数，如果数字个数等于或者小于nums[mid], 这说明重复的数字出现在右侧，这时候更新left = mid + 1；否则的话更新right = mid。</li><li>这样我们的时间复杂度是 $O(nlogn)$, 空间复杂度是 $O(1)$</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        order = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(order) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right)/<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> n &lt;= order[mid]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> count &gt; order[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> order[left]</span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode142-Linked-List-Cycle-II"><a href="#补充-Leetcode142-Linked-List-Cycle-II" class="headerlink" title="补充 - Leetcode142 - Linked List Cycle II"></a>补充 - Leetcode142 - Linked List Cycle II</h1><blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ul><li>查看linked list里面有没有cycle就很直接，设两个pointer 一个一次走一步，一个一次走两步，看两个pointer会不会相遇，如果相遇，那么就说明有cycle，如果与一个pointer率先到达none，也就是最后的端点，那么这个linked list就是没有cycle</li><li>slow 和fast pointer相遇之后，要看一下这个cycle有多长，则固定fast不动，每次走一步slow，看走几步之后slow会和fast相遇，这时候得到了cycle中node的个数，也就是cycle的长度N</li><li>那就等于说，如果我们再设置两个pointer，一个比另一个多N步，那么他们会在某一个相遇，而相遇的位置就是cycle开始的位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># print(fast.val, slow.val)</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                step = slow.<span class="built_in">next</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                p1 = head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">while</span> step != slow:</span><br><span class="line">                    step = step.<span class="built_in">next</span></span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                p2 = head</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                        <span class="keyword">return</span> p1</span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    p2 = p2.<span class="built_in">next</span></span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h1 id="0624-Leetcode96-Unique-Binary-Search-Trees"><a href="#0624-Leetcode96-Unique-Binary-Search-Trees" class="headerlink" title="0624 - Leetcode96 - Unique Binary Search Trees"></a>0624 - Leetcode96 - Unique Binary Search Trees</h1><blockquote><p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p></blockquote><p>解题思路：</p><p>初见这道题，我觉得肯定是用一个动态的思想去做，所以想到了dfs（怎么觉得dfs和dp的想法差不多呢，还是我自己没搞明白）</p><p>一开始我是想对于一个给定的数列nums，我可以分别以其中的一个数nums[i]为root，又因为是binary search tree，所以这个数字左边的部分nums[:i] 和右边的部分 nums[i+1:] 分别就在root的左边和右边。那么动态的去想一想，以nums[i]为root的BST的个数就等于nums[:i]的BTS个数<strong>加上</strong>nums[i+1:] 的BTS的个数。</p><p>但是！这里的<strong>加上</strong> 是不对的，因为如果在nums = [1,2,3]，以2为root时，左边1有一种可能，右边三有一种可能，加起来就是两种可能，所以是不正确的。应该是<strong>乘上</strong>！！</p><p>好，那以nums[i]为root的BTS的个数就等于nums[:i]数列BTS的个数 乘以 nums[i+1:]数列BTS的个数，然后我们遍历nums中所有的i，再把这些加起来。</p><p>这样就可以用DFS去做了。但是，我们还可以进一步的改进它。需要注意的是，我们的数列已经是顺序排列了，所以说，其实在计算BTS的个数的时候，我们不需要去担心数列里的数字是多少。比如，[1,2,3]和[4,5,6]生成的BTS的数目是一样的。所以我们在做DFS的时候，就会产生很多重复计算。这时候，我们就想到用DP了。</p><p>如果需要使用动态规划的算法，那么我们的一维dp[i]矩阵表示的就是，当数列的长度为i的时候，它存在的BTS的数目。</p><ul><li>dp[i] - 当数列的长度为i的时候，它存在的BTS的数目</li><li>状态转移方程 - dp[i] = sum([dp[k] * dp[i-1-k] for k in range(i))</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">  </span><br><span class="line">  dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">#一边为空时，所选方案为1种</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dp)):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">      dp[i] += dp[j] * dp[i<span class="number">-1</span>-j]</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># dfs  -&gt; TLE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.dfs(nums, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, nums, count</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">sum</span>([self.dfs(nums[:i], count) * self.dfs(nums[i+<span class="number">1</span>:], count) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode95-Unique-Binary-Search-Tree-II"><a href="#补充-Leetcode95-Unique-Binary-Search-Tree-II" class="headerlink" title="补充 - Leetcode95 - Unique Binary Search Tree II"></a>补充 - Leetcode95 - Unique Binary Search Tree II</h1><blockquote><p>Given an integer <code>n</code>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>依循着上道题我的DFS的思路，看看能不能接着搞。</p><h1 id="0623-Leetcod222-Count-Complete-Tree-Node"><a href="#0623-Leetcod222-Count-Complete-Tree-Node" class="headerlink" title="0623 - Leetcod222 - Count Complete Tree Node"></a>0623 - Leetcod222 - Count Complete Tree Node</h1><blockquote><p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p><p><strong>Note:</strong></p><p><strong>Definition of a complete binary tree from <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a>:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p></blockquote><p>解题思路：</p><p>本来想用dfs做的，就计数遍历过的node。但没写出来。</p><p>只能用题目中给出的需要计算 tree的depth。</p><p>已知给定的是complete binary tree，那么一定是左子树都填满之后再填右子树，所以说左右子数的深度就很能说明问题。</p><p>如果左右子树的depth相同，那么左子树是满的，可能出现问题的只可能是右子树</p><p>如果左右子树的depth不同，那么右子树是满的，我们需要继续探索左子树看他究竟有几层。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        leftDepth = self.getDepth(root.left)</span><br><span class="line">        rightDepth = self.getDepth(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:</span><br><span class="line">          <span class="keyword">return</span> (<span class="number">2</span>**leftDepth) + self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> (<span class="number">2</span>**rightDepth) + self.countNodes(root.left)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + self.getDepth(root.left)</span><br><span class="line">          </span><br><span class="line">        </span><br></pre></td></tr></table></figure><h1 id="0622-Leetcode137-Single-Number-II"><a href="#0622-Leetcode137-Single-Number-II" class="headerlink" title="0622 - Leetcode137 - Single Number II"></a>0622 - Leetcode137 - Single Number II</h1><blockquote><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>直接解题：</p><p>我们已经知道，除了一位数字之外，其他的数字出现的次数都是三次，那么我们可以将这个list进行set处理，然后求和乘以三，再减去之前未作处理的list求和，之后再除以2就可以得到想要的数字。所以这是一行很简单的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">3</span>*<span class="built_in">sum</span>(<span class="built_in">set</span>(nums)) - <span class="built_in">sum</span>(nums))//<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>位运算：</p><p>我们可以利用二进制将数字都转化，所有出现三次的数字，他们的二级制也是一样的，所以说，每一位的和除以3一定是可以整除的，除非有一个其他的数字出来插一脚。所以我们的做法也很明确了，就是遍历所有位，然后对每一位的数求和并处以3，保存余数。以后再将这个二进制数还原为十进制整数。</p><ul><li>这里的range从32中取值是因为整数最多为32位。最后一步说明当得到的数字是负数的时候，我们要用正数减去最大值得到负数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:                </span><br><span class="line">                count += (j&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans = ans | (count%<span class="number">3</span>) &lt;&lt; i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">2</span>**<span class="number">32</span> <span class="keyword">if</span> ans&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span> == <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></li></ol><h1 id="补充-Leetcode136-Single-Number-I"><a href="#补充-Leetcode136-Single-Number-I" class="headerlink" title="补充 - Leetcode136 - Single Number I"></a>补充 - Leetcode136 - Single Number I</h1><blockquote><p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p><p><strong>Note:</strong></p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>同样，这道题有很多解，第一个就是和之前一样，因为除了一个数字只出现一次之外，别的数字都出现两次，所以我们可以接着把这个list中的数字做set处理求和，然后乘以2再减去处理之前的list求和，就可以得到只出现一次的那个数值了。同样也可以看到一个数字的时候把它放进list中，如果再看见就把它从list用pop出来，最后list中剩下的那个数字就是我们要找的数值。</p><p>这里我们还是讲一下位运算。</p><p>如果两个数字相同，说明他们转化为二进制之后，每一位上的数字个数都是2，除了之前我们说的，可以将每一位求和除以出现的次数2，然后找余数之外。对于出现两次（偶数次）的数字，我们可以做xor处理，即两位相同返回0，不同返回1. 当我们对两个相同的数字 a 和数字 b做 异或运算的时候，如果两个数字相同，那么<code>a^b = 0</code>, 否则的话肯定有一位是1。那么当我们对list中所有的数字做异或运算的时候，最后得到的结果就是多出来的那个数字。 还有一个 <strong>0和任何数字做异或运算都等于他本身</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            xor ^= n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> xor</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode260-Single-Number-III"><a href="#补充-Leetcode260-Single-Number-III" class="headerlink" title="补充 - Leetcode260 - Single Number III"></a>补充 - Leetcode260 - Single Number III</h1><blockquote><p>Given an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>这一题和之前两个题不同之处在于，这里出现一次的数字不止一个了，而是两个，所以之前两个题用到的做set处理之后求和，然后再减去之前的list的和，这种方法就失效了。</p><p>我们还是来考虑位运算。</p><p>既然是位运算，那么我们还是来看一看xor运算能给我们带来什么。之前说过的是，如果两个数字相同，那么做了异或运算之后我们会得到0，对所有数字进行异或运算可以帮助我们得到唯一一个不同的数字。那既然我们现在有两个只出现一次的数字，就说明对所有数字做了异或运算之后，我们得到的是这两个数字异或运算后的结果。</p><p>这个结果也是很重要的，得到的结果至少有一位是1（即两个数字这这一位上是不同的）。那么我们要做的就是找到这一位pointer，然后将nums中的数字分为两个部分。一部分数字在pointer这一位都为0，另一部分数字再pointer这一位都为1，这样的话，这两个数字就会分别处在两个不同的部分。然后我们对每个部分分别作异或运算，就可以得到两个出现一次的数字了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nxor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            nxor = nxor ^ n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> (nxor &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                pointer = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># print(pointer)</span></span><br><span class="line">        nums1 = []</span><br><span class="line">        nums2 = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> (n &gt;&gt; pointer) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                nums1.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums2.append(n)</span><br><span class="line">        <span class="comment"># print(nums1, nums2)</span></span><br><span class="line">        n1 = <span class="number">0</span> </span><br><span class="line">        n2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums1:</span><br><span class="line">            n1 = n1^n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">            n2 = n2^n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> [n1, n2]</span><br></pre></td></tr></table></figure><h1 id="0621-Leetcode174-Dungeon-Games"><a href="#0621-Leetcode174-Dungeon-Games" class="headerlink" title="0621 - Leetcode174 - Dungeon Games"></a><a name="lc174"/>0621 - Leetcode174 - Dungeon Games</h1><blockquote><p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p><p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0’s</em>) or contain magic orbs that increase the knight’s health (<em>positive</em> integers).</p><p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p></blockquote><p>解题思路：（开心，是我自己徒手写的动态规划算法鸭）</p><p>这道题就是标准的动态规划的题目了。捋一捋思路。</p><ul><li><p>涉及二维的，只能通过往右和往下两种路径到达终点的题目，肯定涉及走不同的路径，然后选取到该点的最小cost的类的问题，所以这类问题需要倒着推。</p></li><li><p>首先明确我们dp[i][j] 的意义，既然我们要求的是到达dungeon[i][j]的最小路径和，那么我们就将 dp[i][j] 表示为到达dungeon[i][j] 的最小cost和，而dungeon[i][j]就表示在[i][j]点的cost。</p></li><li><p>然后来找状态转移方程，我们到达[i][j]点至少消耗的体力值，等于我们在[i+1][j]点至少消耗的体力值 + 在 [i-1][j] 消耗/获得 的体力值，或者是等于[i][j+1]点至少消耗的体力值 + 在 [i][j+1] 消耗/获得的体力值，至于选择从哪条路径来，就看哪条路径需要的体力值最小。</p><p>所以我们的状态转移方程为</p><p><code>dp[i][j] = min(dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])</code></p></li><li><p>但有一点需要注意的是，如果 dungeon[i][j] 获得的体力值 大于下一步即将消耗的体力值，那么我们其实获得将要消耗的体力值+1就可以了，因为如果过大，在之前的减法中，就会出现负数。举个例子：如果在<code>dungeon[i+1][j]</code>我们将会获得10点体力值，而到达<code>dp[i][j]</code>至少需要4点体力值的话，那么我们到达<code>dp[i+1][j]</code>时，至少需要有 -6点体力值，这是不可能的，因为如果体力值小于0，王子就死了。所以这个时候，我们到达<code>dp[i+1][j]</code>至少需要5点体力值， 即<code>dp[i+1][j]- dundeon[i][j]&gt;= 1</code>，所以我们的<code>dp[i+1][j]-1 &gt;= dundeon[i][j]</code>, 所以上一步的 <code>dp[i][j] = min(dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])</code> 换为：<code>dp[i][j] = min(dp[i+1][j] - min(dungeon[i][j], dp[i+1][j]-1), dp[i][j+1] - min(dungeon[i][j], dp[i][j+1] - 1))</code></p></li><li><p>Initial Condition:  dp右下角点的值，也就是营救公主所需要的生命力 = <code>1 - min(dungeon[M-1][N-1], 0)</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span>(<span class="params">self, dungeon</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type dungeon: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        M = <span class="built_in">len</span>(dungeon)</span><br><span class="line">        N = <span class="built_in">len</span>(dungeon[<span class="number">0</span>]) </span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == M<span class="number">-1</span> <span class="keyword">and</span> j == N<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> - <span class="built_in">min</span>(dungeon[M<span class="number">-1</span>][N<span class="number">-1</span>], <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">elif</span> i == M<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">1</span>] - <span class="built_in">min</span>(dungeon[i][j], dp[i][j+<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> j == N<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] - <span class="built_in">min</span>(dungeon[i][j], dp[i+<span class="number">1</span>][j] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:                </span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] - <span class="built_in">min</span>(dungeon[i][j], dp[i+<span class="number">1</span>][j]<span class="number">-1</span>), dp[i][j+<span class="number">1</span>] - <span class="built_in">min</span>(dungeon[i][j], dp[i][j+<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="0620-Leetcode60-Permuation-Sequence"><a href="#0620-Leetcode60-Permuation-Sequence" class="headerlink" title=" 0620 - Leetcode60 - Permuation Sequence"></a><a name="lc60"/> 0620 - Leetcode60 - Permuation Sequence</h1><blockquote><p>The set <code>[1,2,3,...,*n*]</code> contains a total of <em>n</em>! unique permutations.</p><p>By listing and labeling all of the permutations in order, we get the following sequence for <em>n</em> = 3:</p><ol><li><code>&quot;123&quot;</code></li><li><code>&quot;132&quot;</code></li><li><code>&quot;213&quot;</code></li><li><code>&quot;231&quot;</code></li><li><code>&quot;312&quot;</code></li><li><code>&quot;321&quot;</code></li></ol><p>Given <em>n</em> and <em>k</em>, return the <em>k</em>th permutation sequence.</p></blockquote><p>解题思路：</p><ol><li><p>暴力求解</p><p>这个方法的时间复杂度会比较高，可能会造成Limit Time exceeded的错误，但是这里想要指出的是permuation这类题的共性，所以在这里指出。</p><p>我们首先要知道的这个nums序列permutation变化的规律：</p><ul><li>两个极端的例子是第一个permutation是从小到大依次排列的组合，第二个则是从大到小依次排列的组合。也就是说当我们的序列中存在非递减序列的时候，还是有下一次permute的可能性的，而当我们的序列已经是一个非递增序列的时候，这个permuation的过程就可以结束了。</li><li>我们要找的下一次permute的序列和本次序列的关系就是：找到本次序列中的非递增序列，然后将这个非递增序列的前一位（nums[pointer]）和非递增序列中稍大于这一位数字（nums[change]）的两项进行交换，最后顺序排列 nums[pointer+1::]</li></ul><p>这种方法可以帮我们按照顺序求解出来所有的permutation，既然我们要找的是第k个permutation，那么就将此步骤重复k-1次（因为第一个permutation不计入）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># print(i, nums)</span></span><br><span class="line">            self.nextPermutation(nums)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        </span><br><span class="line">        pointer = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pointer &gt; <span class="number">0</span>:            </span><br><span class="line">            <span class="keyword">if</span> nums[pointer - <span class="number">1</span>] &gt;= nums[pointer]:</span><br><span class="line">                pointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        pointer -= <span class="number">1</span>        </span><br><span class="line">        change = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> change &gt; pointer:            </span><br><span class="line">            <span class="keyword">if</span> nums[change] &gt; nums[pointer]:                </span><br><span class="line">                nums[change], nums[pointer] = nums[pointer], nums[change]</span><br><span class="line">                nums[pointer+<span class="number">1</span>::] = <span class="built_in">sorted</span>(nums[pointer+<span class="number">1</span>::])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            change -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>直接按照可能出现的序列个数利用mod进行查找</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h1 id="补充-Leetcode31-Next-Permutation"><a href="#补充-Leetcode31-Next-Permutation" class="headerlink" title=" 补充 - Leetcode31 - Next Permutation"></a><a name="lc31"/> 补充 - Leetcode31 - Next Permutation</h1><blockquote><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p><p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p><p>The replacement must be <strong><a href="http://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> and use only constant extra memory.</p><p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;1,2,3<span class="code">` → `</span>1,3,2`</span><br><span class="line">&gt;<span class="code">`3,2,1`</span> → <span class="code">`1,2,3`</span></span><br><span class="line">&gt;<span class="code">`1,1,5`</span> → `1,5,1</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>按照上面总结的permutation的规律就可以得到。需要注意的是，如果permutation已经是最后一个，即倒序排列时，需要返回的是正序的第一个序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pointer = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pointer &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[pointer<span class="number">-1</span>] &gt;= nums[pointer]:</span><br><span class="line">                pointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> pointer == <span class="number">0</span>:</span><br><span class="line">            nums[<span class="number">0</span>::] = nums[::<span class="number">-1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        pointer -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        change = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> change &gt; pointer:</span><br><span class="line">            <span class="keyword">if</span> nums[change] &gt; nums[pointer]:</span><br><span class="line">                nums[change], nums[pointer] = nums[pointer], nums[change]</span><br><span class="line">                nums[pointer+<span class="number">1</span>::] = <span class="built_in">sorted</span>(nums[pointer+<span class="number">1</span>::])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            change -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="0619-Leetcode1044-Longest-Duplicate-Substring"><a href="#0619-Leetcode1044-Longest-Duplicate-Substring" class="headerlink" title=" 0619 - Leetcode1044 - Longest Duplicate Substring"></a><a name="lc1044"/> 0619 - Leetcode1044 - Longest Duplicate Substring</h1><blockquote><p>Given a string <code>S</code>, consider all <em>duplicated substrings</em>: (contiguous) substrings of S that occur 2 or more times. (The occurrences may overlap.)</p><p>Return <strong>any</strong> duplicated substring that has the longest possible length. (If <code>S</code> does not have a duplicated substring, the answer is <code>&quot;&quot;</code>.)</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;banana&quot;</span><br><span class="line">Output: &quot;ana&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcd&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>Rabin Carp + Binary Search</p><p>这题但凡是有一点的修改都会因为时间复杂度太高而无法通过。</p><p>首先来说说主要的想法Binary Search吧，个人感觉Rabin Carp只是为了降低搜索时候的时间复杂度而改变的。</p><p>这道题我们想要知道的是在string中重复出现的最长substring是什么。换个角度思考一下，如果我们给定了substring的长度，然后让你找这个长度下的substring有没有重复出现的，那么问题就会变得很清晰。这时候我们就可以用二分答案的方法来解决这个问题。假设最长substring的长度是m，那么substring长度为m-1， m-2，… 1的substring也会出现重复值。所以我们就可以用二分答案的方法来找到最长重复出现的substring。</p><ul><li>当 长度为length的substring找不到重复的时候，说明这个长度太长了，所以我们就更新右边的端点到mid</li><li>当长度为length的substring可以找到重复string的时候，说明我们能找到的substring可能比这个还长，所有我们就更新左边的端点到mid</li></ul><p>其次就是 Rabin Carp，这个是把每个长度的substring用一个数字来表示，然后放在一个set里面，放在string里面并且判断这个数字是否在string中是不行的，会超过时间，set的计算效率是高于list的。</p><p>这个将string转化为一个数字的过程就是Rabin Carp算法。我们需要知道的是string中总共可能出现的数字是多少，然后将每个可能出现的字符用一个数字来表示。这里，所有可能出现的字符就是26个字母，所以a-0, b-1, c-2, …这些表示出来就可以了。个人觉得将这个string转化为数字就好像26进制一样，每个不同组合的string都会有对应的数字，然后再将这些数字储存在set中。为了防止重复出现的数字，我们将26进制转化后的数字mod by一个很大的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDupSubstring</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        A = [<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> S]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">testString</span>(<span class="params">length, MOD</span>):</span></span><br><span class="line">    </span><br><span class="line">            cur_hash = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mid):</span><br><span class="line">                cur_hash = (cur_hash * <span class="number">26</span> + A[i]) % MOD</span><br><span class="line">                </span><br><span class="line">            string_set = &#123;cur_hash&#125;</span><br><span class="line">            max_pow = <span class="built_in">pow</span>(<span class="number">26</span>, length, MOD)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length, <span class="built_in">len</span>(S)):</span><br><span class="line">                <span class="comment"># print(string_set)</span></span><br><span class="line">                cur_hash = (cur_hash * <span class="number">26</span> - A[i - length]*max_pow + A[i]) % MOD</span><br><span class="line">                <span class="keyword">if</span> cur_hash <span class="keyword">in</span> string_set:</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span> - length</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    string_set.add(cur_hash)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>   </span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(S) - <span class="number">1</span></span><br><span class="line">        MOD = <span class="number">2</span>**<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            pos = testString(mid, MOD)</span><br><span class="line">            <span class="comment"># print(pos)</span></span><br><span class="line">            <span class="keyword">if</span> pos != <span class="number">-1</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                ans = S[pos:pos+mid]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Suffix Array + Longest Common Prefix</p><p>这个方法就很巧妙了，主要是找到这个string从头开始的substring，然后再将这个substring排序，之后找这些substring里面最长的前缀。</p><ul><li><p>首先需要提取字符串的所有suffix，也就是后缀。</p><p>为什么要取后缀呢？因为按照brute borce的思想，假设我们先确定了一个字符i的位置，我们会做的是，在i后面的每一个字符起，开始遍历，试图去找一下是否有重复substring。所以我们要先把suffix提取出来</p></li><li><p>然后按照suffix的字母顺序进行排序。其实这个步骤就是隐性的帮我们把有重复项的suffix排在了一起，我们要做的就是找current suffix和它之后的suffix有多长重复的prefix（也就是当拿出两个已排好序的相邻的suffix从头进行比较，看两者最长的重复substring是什么）。</p></li><li><p>找出的最长prefix就被称作是Longest Common Prefix，这样也是可以解决这个问题的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><h1 id="0618-Leetcode275-H-index-II"><a href="#0618-Leetcode275-H-index-II" class="headerlink" title=" 0618 - Leetcode275 - H-index II"></a><a name="lc275"/> 0618 - Leetcode275 - H-index II</h1><blockquote><p> Given an array of citations <strong>sorted in ascending order</strong> (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the <a href="https://en.wikipedia.org/wiki/H-index">definition of h-index on Wikipedia</a>: “A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.”</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: citations &#x3D; [0,1,3,5,6]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had </span><br><span class="line">             received 0, 1, 3, 5, 6 citations respectively. </span><br><span class="line">             Since the researcher has 3 papers with at least 3 citations each and the remaining </span><br><span class="line">             two with no more than 3 citations each, her h-index is 3.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>二分法查找：</p><p>首先明确目标：我们要找最小的能使 citations[i] &gt;= len(citations) - i 的值</p><p>因为这里的citations中的数字都被排序了，所以我们可以使用二分法。</p><ul><li><p>首先设置的是左右两边的pointer: left = 0, right = len(citations) - 1</p></li><li><p>设置循环条件：while left &lt; right </p></li><li><p>更新：left = mid + 1; right = mid </p><p>更新的条件是判断citations[mid] &gt;= len(citations) - mid</p><p>如果该条件成立，说明我们要找的点就在mid或是mid的左边(不一定mid这一点是最小的能满足这个条件的点)，所以这时我们更新right = mid </p><p>如果该条件不成立，即citations[mid] &lt; len(citations) - mid，说明我们要找的点一定在mid的右边，所有我们更新 left = mid + 1</p></li><li><p><strong>因为我们的循环条件是 while left &lt; right</strong> 所以当left == right的时候，并没有审核citations[left]这个值符不符合要求，所以我们在最后需要再加上判别条件</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(citations) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                   </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(citations) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right)/<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= <span class="built_in">len</span>(citations) - mid:</span><br><span class="line">                right = mid </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> citations[left] &gt;= <span class="built_in">len</span>(citations) - left:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(citations) - left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(citations) - (left+<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>Brute force：</p><p>设置pointer i从0开始，i代表的位置就是我们找到的最小的能使 citations[i] &gt;= len(citations) - i 的值。</p><ul><li>当 citations[i] &lt; len(citations) - i的时候，意味着，在i点被引用的次数小于从i开始的文章数目，需要将i往后移动一位。</li><li>当 citations[i] &gt;= len(citations) - i 的时候，意味着在i点，被引用的次数大于等于后面的文章数目了，所以此时我们已经找到了可以满足条件的i的位置，需要返回的是从i开始一共有几篇文章的数目，即len(citations) - i</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hIndex</span>(<span class="params">self, citations</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(citations):</span><br><span class="line">            <span class="keyword">if</span> citations[i] &gt;= <span class="built_in">len</span>(citations) - i:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(citations) - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="0617-Leetcode130-Surrounded-Regions"><a href="#0617-Leetcode130-Surrounded-Regions" class="headerlink" title=" 0617 - Leetcode130 - Surrounded Regions"></a><a name="lc130"/> 0617 - Leetcode130 - Surrounded Regions</h1><blockquote><p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p><p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p><p><strong>Explanation:</strong></p><p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p></blockquote><p>解题思路：</p><p>这是一个联合分量的问题。</p><p>并不是说你网格中O的周围只要有一个是X，他就一定是X，，或者网格中的O周围有一个是O他就一定是O而是要看他边界的O是否相连接。</p><p>其实这里主要的一个思路是，如果网格中的O和边界上的O相连接，那么网格中的O就不用换成X，所以换个说法，我们在边界上寻找O，然后再看它和网格中间的哪些O相连，将这些O标记成新的量G，之后将所有没有被标记为G的O点，也就是不和外界相连的O点换成X。</p><p>用到的主要方法就是DFS，即我们寻找边界上的O，然后在他的上下左右方向寻找相连的O，将这些点标记为G。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(board) &lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">markG</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j]!=<span class="string">&#x27;O&#x27;</span>: <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                board[i][j] = <span class="string">&#x27;G&#x27;</span></span><br><span class="line">                markG(i<span class="number">-1</span>, j)</span><br><span class="line">                markG(i+<span class="number">1</span>, j)</span><br><span class="line">                markG(i, j<span class="number">-1</span>)</span><br><span class="line">                markG(i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            markG(i, <span class="number">0</span>)</span><br><span class="line">            markG(i, <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            markG(<span class="number">0</span>, j)</span><br><span class="line">            markG(<span class="built_in">len</span>(board) - <span class="number">1</span>, j)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode200-Number-of-Islands"><a href="#补充-Leetcode200-Number-of-Islands" class="headerlink" title="补充 - Leetcode200 - Number of Islands"></a>补充 - Leetcode200 - Number of Islands</h1><blockquote><p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>这题和上一题是一样的，就是我们找到一个小岛之后，要把和它相连的部分都标记为“已遍历”，这里没有flag，就直接用一个别的符号来表示。然后当我们再次遇到这个点的时候就不会再遍历，造成重复。</p><p>唯一一点和上面一题不同的是，上面一题，只有和边界相接触的点才有可能被保存下来，但是这里只要是出现了1，我们就把他当做是一个岛。所以这里在写for循环的时候，需要遍历每一个 为 1 的点，并且我们遇到1的时候count+1。count累加不能写在dfs函数的里面，我们在把和之前1相邻的点标记为“已遍历”的时候就会不停地累加。这个累加要出现在我们发现一个 1 的时候。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">markG</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j&gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">                markG(i+<span class="number">1</span>, j)</span><br><span class="line">                markG(i<span class="number">-1</span>, j)</span><br><span class="line">                markG(i, j+<span class="number">1</span>)</span><br><span class="line">                markG(i, j<span class="number">-1</span>)</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># print(grid)</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    markG(i, j)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode547-Friend-Circles"><a href="#补充-Leetcode547-Friend-Circles" class="headerlink" title=" 补充 - Leetcode547 - Friend Circles"></a><a name="lc468"/> 补充 - Leetcode547 - Friend Circles</h1><blockquote><p>There are <strong>N</strong> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <strong>direct</strong> friend of B, and B is a <strong>direct</strong> friend of C, then A is an <strong>indirect</strong> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p><p>Given a <strong>N*N</strong> matrix <strong>M</strong> representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are <strong>direct</strong> friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p><p><strong>Example 1:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, </span><br><span class="line">so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ol><li>N is in range [1,200].</li><li>M[i][i] = 1 for all students.</li><li>If M[i][j] = 1, then M[j][i] = 1.</li></ol></blockquote><p>解题思路:</p><p>同样是用DFS搜索方法，但是和之前小岛不同的是，这里的是否交朋友是无序的，所以我们不能光考虑上下左右的边界，需要考虑的是所在行的所有数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, M</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">markFriend</span>(<span class="params">i</span>):</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)):</span><br><span class="line">                <span class="keyword">if</span> M[i][k] == <span class="number">1</span>:</span><br><span class="line">                    M[i][k] = <span class="number">2</span></span><br><span class="line">                    M[k][i] = <span class="number">2</span></span><br><span class="line">                    markFriend(k)         </span><br><span class="line">                </span><br><span class="line">        count = <span class="number">0</span>     </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)):</span><br><span class="line">            <span class="keyword">if</span> M[i][i] == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                M[i][i] = <span class="number">2</span></span><br><span class="line">                markFriend(i)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h1 id="0616-Leetcode468-Validate-IP-Address"><a href="#0616-Leetcode468-Validate-IP-Address" class="headerlink" title=" 0616 - Leetcode468 - Validate IP Address"></a><a name="lc468"/> 0616 - Leetcode468 - Validate IP Address</h1><blockquote><p>Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.</p><p><strong>IPv4</strong> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (“.”), e.g.,<code>172.16.254.1</code>;</p><p>Besides, leading zeros in the IPv4 is invalid. For example, the address <code>172.16.254.01</code> is invalid.</p><p><strong>IPv6</strong> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (“:”). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).</p><p>However, we don’t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.</p><p>Besides, extra leading zeros in the IPv6 is also invalid. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is invalid.</p><p><strong>Note:</strong> You may assume there is no extra space or special characters in the input string.</p></blockquote><p>解题思路：</p><p>这个题看似简单，就是判断输入的字符串是IPv4还是IPv6，但实际太复杂了，这两种地址的条条框框太多了，一开始我是自己写的，后来test case实在无法通过，就参考了<a href="https://leetcode.com/problems/validate-ip-address/discuss/95484/PythonJava-Easy-Understand-Solution">这里</a> 的写法。</p><p>我们就来分析一下：</p><ul><li>IPv4<ol><li>当用 ‘.’ 将字符串split开的时候，长度必须为4（说的是有四个分开的部分，三个 ‘.’）</li><li>每个split出来的字符串的都必须是数字，长度不能超过3，但是不能以0开头</li><li>每个split出来的字符串中的数字不能为-1（谁能想到test case里面还有-1）</li></ol></li><li>IPv6<ol><li>当用 ‘:’ 字符串split开的时候，长度必须是8</li><li>每个split出来的字符串都必须是16进制，长度不能超过4，可以以0开头</li><li>每个split出来的字符串中的数字不能为-1</li></ol></li><li><strong>最好用try except去做，不然其他的情况太多了，不能完全覆盖</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIPv4</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">    <span class="comment">#检查的是每个被 ‘.’ 隔离开的字符串</span></span><br><span class="line">    <span class="comment"># 1. str(int(s)) == s 检查字符串中的数字是否以0开头, 还可以避免-0的情况</span></span><br><span class="line">    <span class="comment"># 2. 0 &lt;= int(s) &lt;= 255 检查字符串中的数字是否在规定范围内</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(s)) == s <span class="keyword">and</span> <span class="number">0</span> &lt;= <span class="built_in">int</span>(s) &lt;= <span class="number">255</span></span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIPv6</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">4</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">      <span class="comment"># int(s, 16) 是将s由16进制转化为十进制的整数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">int</span>(s, <span class="number">16</span>) &gt;= <span class="number">0</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validIPAddress</span>(<span class="params">self, IP</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type IP: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> IP.count(<span class="string">&quot;.&quot;</span>) == <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">all</span>(self.isIPv4(i) <span class="keyword">for</span> i <span class="keyword">in</span> IP.split(<span class="string">&quot;.&quot;</span>)): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span></span><br><span class="line">    <span class="keyword">if</span> IP.count(<span class="string">&quot;:&quot;</span>) == <span class="number">7</span> <span class="keyword">and</span> <span class="built_in">all</span>(self.isIPv6(i) <span class="keyword">for</span> i <span class="keyword">in</span> IP.split(<span class="string">&quot;:&quot;</span>)): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br></pre></td></tr></table></figure><h1 id="0615-Leetcode700-Search-in-a-binary-tree"><a href="#0615-Leetcode700-Search-in-a-binary-tree" class="headerlink" title=" 0615 - Leetcode700 - Search in a binary tree"></a><a name="lc700"/> 0615 - Leetcode700 - Search in a binary tree</h1><blockquote><p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL.</p></blockquote><p>解题思路：</p><p>binary search tree</p><p>这里对于每个节点的左右进行搜索.因为binary search tree左右两边的node都是有大小顺序的，所以比较好排查，若果节点的val等于要找的value的值，那么就返回这个节点（所代表的tree），否则就一直往下找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">if</span> val&gt;root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> val&lt;root.val:</span><br><span class="line">                root = root.left</span><br></pre></td></tr></table></figure><h1 id="0614-Leetcode787-Cheapest-Flights-within-K-stops"><a href="#0614-Leetcode787-Cheapest-Flights-within-K-stops" class="headerlink" title=" 0614 - Leetcode787 - Cheapest Flights within K stops."></a><a name="lc787"/> 0614 - Leetcode787 - Cheapest Flights within K stops.</h1><blockquote><p>There are <code>n</code> cities connected by <code>m</code> flights. Each flight starts from city <code>u</code> and arrives at <code>v</code> with a price <code>w</code>.</p><p>Now given all the cities and flights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 1</span><br><span class="line">Output: 200</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li>动态规划：</li></ol><p>这题我一开始是想用动态规划来写的，但是这个dp矩阵我不知道怎么写。因为和之前的dp不同的是，图是无序的，所以无法用每个node的值来做横纵坐标，也就是说如果用城市的编号来写dp，然后每多走一步我们就滚动加上次的dp，是没法做的。</p><p>因此我琢磨了一下这道题对应的动态规划问题，也就是Bellman-ford’s方法，然后现在大概明白怎么进行了。</p><p>首先我们构建一个dp矩阵, dp[k][v] 代表在最多走k步的情况下，从起始点到点v的最短路程距离是多少。所以其实最终得到的dp矩阵可以告诉我们从src到每一个点的（最多走k步时）的路程距离，但最后返回的时候，我们只需要返回v = dst的值。</p><p>来看看动态规划问题：</p><ul><li>子问题：当最多可以走k步时，从src到v的最短距离为：最多走k-1步，从src到v的最短距离 以及 最多走k-1步，src到u的最短距离+u到v的距离 当中的最小值。</li><li>状态转移方程： dp[k][v] = min(dp[k-1][v], dp[k-1][u]+cost[u][v])</li></ul><p>我们来看看图：</p><p><img src="/images/Note%20Jun%206,%202020-2274380.jpeg" alt="Note Jun 6, 2020-2274380"></p><p>dp矩阵图：</p><p><img src="/images/Note%20Jun%206,%202020-2.jpeg" alt="Note Jun 6, 2020-2"></p><ul><li>首先，规定我们的参数：src = 0, dst = 2, k = 1, n = 5, edge的长度如图所示。</li><li>明确几点common sense：<ol><li>因为我们的出发点是src，所以当v=src（终点等于起点）的时候，dp[k][src] = 0. 翻译一下，也就是说，当我们最多走k步的时候, src到自己的最短距离都是0</li><li>因为我们考虑的情况是，当你走的步数变多，到达dst的距离可能会缩短，所以说，k-1步的距离肯定要大于等于k步的距离，即dp[k-1][dst] &gt;= dp[k][dst]，所以dp[k][dst]的初始值就是dp[k-1][dst]。dp[k][dst] = dp[k-1][dst]表示多给出来我们走的那一步机会我们不用。</li><li>如果要更新src到dst的距离，我们关心的是能到dst的点的上一步的最短距离。那这个例子来说，如果我们的dst为2，在更新的时候我们只关注src到0，1，3点的最短距离，因为只有这三个点可以到达2.所以我们在从edges这个list构建cost函数的时候也需要注意。如果不想考虑这些内容，那么没有连接的两个node之前的距离可以记做 $\infty$</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">self, n, flights, src, dst, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type flights: List[List[int]]</span></span><br><span class="line"><span class="string">        :type src: int</span></span><br><span class="line"><span class="string">        :type dst: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cost = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cost[i] = &#123;&#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> flights:</span><br><span class="line">            cost[f[<span class="number">1</span>]][f[<span class="number">0</span>]] = f[<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;Inf&#x27;</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">2</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][src] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> j == src:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                    <span class="keyword">for</span> u <span class="keyword">in</span> cost[j]:</span><br><span class="line">                        <span class="comment"># print(dp[i-1][u]+cost[j][u], dp[i-1][j])</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][u]+cost[j][u], dp[i][j])</span><br><span class="line">                        <span class="comment"># print(dp[i][j])</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">if</span> dp[K+<span class="number">1</span>][dst] == <span class="built_in">float</span>(<span class="string">&#x27;Inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[K+<span class="number">1</span>][dst]</span><br></pre></td></tr></table></figure><ol><li>深度优先搜索</li></ol><h1 id="0613-Leetcode368-Largest-Divisible-Subset"><a href="#0613-Leetcode368-Largest-Divisible-Subset" class="headerlink" title="0613 - Leetcode368 - Largest Divisible Subset"></a><a name="lc368"/>0613 - Leetcode368 - Largest Divisible Subset</h1><blockquote><p>Given a set of <strong>distinct</strong> positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:</p><p>Si % Sj = 0 or Sj % Si = 0.</p><p>If there are multiple solutions, return any subset is fine.</p></blockquote><p>解题思路：</p><p>排序之后 + 动态规划</p><ul><li><p>排序的原因：假设 $a&lt;b&lt;c$ ， 如果 $b\%a = 0$ 且 $c\%b = 0$, 那么我们就不用计算 $c \% a = 0$, 而且在排序之后不会出现 被除数比除数大的情况。</p></li><li><p>动态规划子问题：假设我们用sol[k]来表示，输入数列中nums中的第l个数字对应的最长divisible序列。那么对于第j个数字，sol[j]的序列将会是 sol[i] + nums[j], where nums[j]%nums[i] == 0.</p></li><li><p>状态转移方程：sol[j] = sol[i] + nums[j]</p><p>注意这里需要有两个限定条件： 1. nums[j]%nums[i] == 0，这点是必须的，用来寻找nums[j]的可整除项；2. len(sol[j]) + 1 &gt; len(sol[i]) ，这个在判定当前sol[j]的序列的长度加上nums[i] 是否大于sol[j]来已经有的序列长度。</p><p><strong>万万不可</strong> 在找到了nums[j]%nums[i] == 0 就break啊，这样的话可能会错失更长的序列。比如，<code>[4, 8, 10, 240]</code> 这个就会输出 <code>[10, 240]</code>而不是<code>[4, 8, 240]</code>了</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        sol = [[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] % nums[j] == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(sol[j]) + <span class="number">1</span> &gt; <span class="built_in">len</span>(sol[i]):</span><br><span class="line">                    sol[i] = sol[j] + [nums[i]]</span><br><span class="line">                    </span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sol, key=<span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><h1 id="补充-Leetcode300-Longest-Increasing-Subsequence"><a href="#补充-Leetcode300-Longest-Increasing-Subsequence" class="headerlink" title="补充 - Leetcode300 - Longest Increasing Subsequence"></a><a name="lc300"/>补充 - Leetcode300 - Longest Increasing Subsequence</h1><blockquote><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ul><li>和上面lc368是一样的哦，只不过这里不涉及排序的问题，直接用动态规划就好了。</li><li>subsequence不意味着数字要连起来，所以和之前一样，也要遍历当前项之前的所有可能序列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        sol = [[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i] <span class="keyword">and</span> <span class="built_in">len</span>(sol[j])+<span class="number">1</span> &gt; <span class="built_in">len</span>(sol[i]):</span><br><span class="line">                    sol[i] = sol[j] + [nums[i]]</span><br><span class="line">                    </span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>([<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> sol])</span><br></pre></td></tr></table></figure><p><a name="lc380"/> 0612 - Leetcode380 - Insert Delete GetRandom O(1)</p><blockquote><p>Design a data structure that supports all following operations in <em>average</em> <strong>O(1)</strong> time.</p><ol><li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li><li><code>remove(val)</code>: Removes an item val from the set if present.</li><li><code>getRandom</code>: Returns a random element from current set of elements. Each element must have the <strong>same probability</strong> of being returned.</li></ol></blockquote><p>解题思路：</p><p>重点就是要用基本的数据结构去解决问题。这里用到了dictionary，可以用dictionary的key来存储值，value来存储位置，因为同一个数值只能出现一次，所以可以很好的运用dictionary.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.pos = &#123;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.nums:</span><br><span class="line">            self.pos[val] = <span class="built_in">len</span>(self.nums) </span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.nums:</span><br><span class="line">            idx = self.pos[val]</span><br><span class="line">            self.nums[idx], self.nums[<span class="number">-1</span>] = self.nums[<span class="number">-1</span>], self.nums[idx]</span><br><span class="line">            self.pos[self.nums[idx]] = idx</span><br><span class="line">            <span class="keyword">del</span> self.pos[self.nums[<span class="number">-1</span>]]</span><br><span class="line">            </span><br><span class="line">            self.nums.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        idx = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.nums[idx]</span><br></pre></td></tr></table></figure><h1 id="0611-Leetcode75-Sorting-Colors-Medium"><a href="#0611-Leetcode75-Sorting-Colors-Medium" class="headerlink" title=" 0611 - Leetcode75 - Sorting Colors - Medium"></a><a name="lc75"/> 0611 - Leetcode75 - Sorting Colors - Medium</h1><blockquote><p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p><p><strong>Example:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>因为存在三种颜色，所以用两次排序并且记录每个数字的个数是可以重新覆盖掉这个数组</p></li><li><p>存在三种颜色，我们可以用两个pointer分别从左右两端出发，左边的pointer卡在左侧1的位置，右边的pointer卡在右侧1的位置。还有一个pointer用来遍历。</p><p><strong>注意</strong>：控制循环的条件是k &lt;=j， 因为j移动的位置是已经排序过的，所以大于j的部分不需要考虑。考虑等于j是因为j所在的位置也还没有考虑，所以需要控制 k&lt;=j.</p><p>如果考虑 i &lt; j 会出现移动的pointer k一直往后移动，导致大于j的已经排序好的部分被打乱。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= j:</span><br><span class="line">        <span class="keyword">if</span> nums[k] &lt; <span class="number">1</span>:</span><br><span class="line">            nums[k], nums[i] = nums[i], nums[k]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[k] == <span class="number">1</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[k] &gt; <span class="number">1</span>:</span><br><span class="line">            nums[k], nums[j] = nums[j], nums[k]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="0610-Leetcode35-Search-Insert-Position-Easy"><a href="#0610-Leetcode35-Search-Insert-Position-Easy" class="headerlink" title=" 0610 - Leetcode35 - Search Insert Position - Easy"></a><a name="lc35"/> 0610 - Leetcode35 - Search Insert Position - Easy</h1><p><a href="https://capchenxi.github.io/2020/01/09/Algorithm-Leetcode-array/#lc35">详解看这里</a></p><h1 id="0609-Leetcode392-Is-Subsequence"><a href="#0609-Leetcode392-Is-Subsequence" class="headerlink" title=" 0609 - Leetcode392 - Is Subsequence"></a><a name="lc392"/> 0609 - Leetcode392 - Is Subsequence</h1><blockquote><p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><p>重点：</p><ol><li>从利用两个pointer的角度，是一道比较简单的题，直接按顺序跑一遍就行。</li><li>从动态规划的角度，要考虑如何把这个问题想象成一个子问题。</li></ol><p>解题思路：</p><ol><li><p>Pointer.</p><p>在string和target里面分别设置两个pointer，然后遍历target里面的所有值，直到在string中都找到相应的值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[j] == s[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></li><li><p>动态规划</p><ol><li>动态规划矩阵: dp[i][j] 代表string[:i] 中是否包含target[:j]</li><li>子问题：dp[i][j] 是否为True取决于dp[i-1][j-1] 以及string[i]和target[j]</li><li>状态转移方程：<ul><li>当string[i]==target[j]时，若dp[i-1][j-1]为True，那么dp[i][j]也为True</li><li>当string[i]!=target[j]时，相当于此时string[i]是没用的，我们需要看dp[i-1][j]是否为True（表示当我们忽略掉string[i]的时候，string[:i-1] 中是否包含target[:j]）</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :type t: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [[<span class="literal">False</span>]*(<span class="built_in">len</span>(t)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(t)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[row - <span class="number">1</span>] == t[col - <span class="number">1</span>]:</span><br><span class="line">                dp[row][col] = dp[row - <span class="number">1</span>][col - <span class="number">1</span>]                    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[row][col] = dp[row][col - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol><h1 id="补充-Leetcode115-Distinct-Subsequence-Hard"><a href="#补充-Leetcode115-Distinct-Subsequence-Hard" class="headerlink" title=" 补充 - Leetcode115 - Distinct Subsequence - Hard"></a><a name="lc115"/> 补充 - Leetcode115 - Distinct Subsequence - Hard</h1><blockquote><p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p><p>It’s guaranteed the answer fits on a 32-bit signed integer.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line"><span class="code">    ^^^</span></span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><ol><li><p>动态规划：</p><ol><li>动态规划矩阵： dp[i][j]表示string[:i] 中否包含target[:j]的不同组合个数</li><li>子问题：dp[i][j] 代表的个数取决于dp[i-1][j-1] 以及string[i]和target[j]</li><li>状态转移方程：<ul><li>当string[i] == target[j] 时，dp[i][j] = dp[i-1][j-1] + dp[i][j-1] 表示当前两个字符相同的时候，现有组合数为dp[i-1][j-1] 加上dp[i][j-1] （考虑或者不考虑string[i]）</li><li>当string[i] ！= target[j]时，dp[i][j] =  dp[i][j-1]  表示只能跳过target[i] 看看 string[:i]能不能在target[:j-1]中出现了几次。</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        M = <span class="built_in">len</span>(s)</span><br><span class="line">        N = <span class="built_in">len</span>(t)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]= [<span class="number">1</span>]*(M+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t[i<span class="number">-1</span>] == s[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[N][M]</span><br></pre></td></tr></table></figure></li></ol><h1 id="0608-Leetcode231-Power-Of-Two-Easy"><a href="#0608-Leetcode231-Power-Of-Two-Easy" class="headerlink" title=" 0608 - Leetcode231-Power Of Two - Easy"></a><a name="lc231"/> 0608 - Leetcode231-Power Of Two - Easy</h1><blockquote><p>Given an integer, write a function to determine if it is a power of two.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: 1</span><br><span class="line">&gt;Output: true </span><br><span class="line">&gt;Explanation: 2^0 = 1</span><br></pre></td></tr></table></figure></blockquote><p>重点：</p><ol><li>注意输入<strong>小于等于</strong>零的状况</li><li>注意在递归时的return标记</li></ol><p>解题思路：</p><ol><li><p>Iteration</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            n = n / <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p>Recursive</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.isPowerOfTwo(n/<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><h1 id="0607-Leetcode518-Coin-Change-2"><a href="#0607-Leetcode518-Coin-Change-2" class="headerlink" title=" 0607 - Leetcode518 - Coin Change 2"></a><a name="lc518"/> 0607 - Leetcode518 - Coin Change 2</h1><blockquote><p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 5, coins = [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure></blockquote><p>重点：</p><ol><li>因为每个币值的coin的数量是无限的，所以我们在选择换零钱方案的时候，都可以选择使用或者不使用该币值的coin。</li><li>首先想到的方法是循环，但在循环的过程中也会产生重复的计算过程会超过time limit，所以提示我们可以用动态规划。</li></ol><p>解题思路：</p><ol><li><p>递归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> self.countSol(amount, coins, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSol</span>(<span class="params">self, amount, coins, i</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(coins) - <span class="number">1</span> <span class="keyword">and</span> amount &gt; <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.countSol(amount - coins[i], coins, i) + self.countSol(amount, coins, i + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>动态规划</p><p>动态规划的思路和刚才的递归的思路相似，但要如何构建DP空间呢？</p><p>之前我们所找到的状态转移方程是：某一(amount, coins)的方案数 = 考虑(coins[0])的状态数 + 不考虑该(coins[0]))的状态数。</p><p>假设一维动态矩阵dp[i], dp[i]表示：为了得到amount为i的结果，目前的coin有几种表达形式。</p><p>初始化： dp = [0]*(amount+1) 表示在没有coin的时候，生成i&gt;0每一种结果的方式都是0. 除了 dp[0] = 1.</p><p>第一次循环：考虑coin[0]， 在更新dp[i]之前，dp[i] 本身表示的就是生成该amount为i的方案中，不考虑coin[0] 时，我们有几种方法，而更新后的dp[i]还要加上dp[i-coin[0]]，表示拥有coin[0]之后，dp[i-coin[0]]个方法也可以被我们所用到了。</p><p>之后的循环都是一样的方法。</p><p>要注意的是，当在第j次循环下，如果 coin[j] &gt; i, 即coin[j]本身币值的大小，大于所需的amount值，那么新考虑的coin[j]对这些amount是没影响的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> coins[i] &lt;= j:</span><br><span class="line">                    dp[j] = dp[j] + dp[j - coins[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li></ol><h1 id="补充-LeetCode322-Coin-Change"><a href="#补充-LeetCode322-Coin-Change" class="headerlink" title=" 补充 - LeetCode322 - Coin Change"></a><a name="lc322"/> 补充 - LeetCode322 - Coin Change</h1><blockquote><p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>和之前的一样，考虑动态规划问题，划分成subproblem，当前amount可得到的最小数量的coin和为（当前最小数量，dp[amount-coin[i]]+1）中的最小值。</p><p>重点：</p><ol><li>初始化的时候每一项初始化为 amount +1, 因为amount最多需要amount数量的coin</li><li>在判断能否生成该amount时只需判断dp[amount]是否仍为amount+1即可。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins, amount</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i]:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j - coins[i]] + <span class="number">1</span>, dp[j])</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> dp[amount] == (amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h1 id="0606-Leetcode1029-Two-City-Scheduling-Easy"><a href="#0606-Leetcode1029-Two-City-Scheduling-Easy" class="headerlink" title=" 0606 - Leetcode1029 - Two City Scheduling - Easy"></a><a name="lc1029"/> 0606 - Leetcode1029 - Two City Scheduling - Easy</h1><blockquote><p>There are <code>2N</code> people a company is planning to interview. The cost of flying the <code>i</code>-th person to city <code>A</code> is <code>costs[i][0]</code>, and the cost of flying the <code>i</code>-th person to city <code>B</code> is <code>costs[i][1]</code>.</p><p>Return the minimum cost to fly every person to a city such that exactly <code>N</code> people arrive in each city.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: </span><br><span class="line">The first person goes to city A for a cost of 10.</span><br><span class="line">The second person goes to city A for a cost of 30.</span><br><span class="line">The third person goes to city B for a cost of 50.</span><br><span class="line">The fourth person goes to city B for a cost of 20.</span><br><span class="line"></span><br><span class="line">The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</span><br></pre></td></tr></table></figure></blockquote><p>解题思路：</p><p>1 -  遍历+排序</p><p>假设全部人被送往A，则我们的花费为 $\sum\limits_{i = 1}^{2N}cost[i][0]$。 </p><p>那我们的任务就变换为，从这A个人中挑选出来N个人，使他们的refund$ \sum\limits_{j=(1)}^{(N)}(- cost[i][0] + cost[i][1])$达到最大值。所以要做的就很简单，是把所有人的refund找出来，然后挑选前N个最大的。</p><p>（如果第$i$ 个人不去A了，改成去B，那么我们可以省去$cost[i][0] - cost[i][1]$这么多钱，省得越多越好）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoCitySchedCost</span>(<span class="params">self, costs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type costs: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        costA = <span class="built_in">sum</span>([c[<span class="number">0</span>] <span class="keyword">for</span> c <span class="keyword">in</span> costs])</span><br><span class="line">        save = [c[<span class="number">0</span>] - c[<span class="number">1</span>] <span class="keyword">for</span> c <span class="keyword">in</span> costs]</span><br><span class="line">        </span><br><span class="line">        save.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> costA - <span class="built_in">sum</span>(save[<span class="built_in">len</span>(costs)/<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>2 - 动态规划</p><p>假设一个 $N \times N$ 的矩阵为DP矩阵，dp[i][j] 表示当i个人去A， j个人去B时的cost，所以dp矩阵的最后一项 dp[N][N] 代表N个人去A， N个人去B的cost。</p><ul><li>初始状态：第0行中的dp[0][j] 表示0个人去A，j个人去B；同样 dp[i][0]表示i个人去A， 0个人去B。</li><li>状态转移方程：</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;【LeetCode】- June Challenge&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc1029&quot;&gt;0606 - Leetcode1029 - Two City Scheduling - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc518&quot;&gt;0607 - Leetcode518 - Coin Change 2 - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc322&quot;&gt;补充 - Leetcode322 - Coin Change - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc231&quot;&gt;0608 - Leetcode231-Power Of Two - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc392&quot;&gt;0609 - Leetcode392 - Is Subsequence - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc115&quot;&gt;补充 - Leetcode115 - Distinct Subsequence - Hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc35&quot;&gt;0610 - Leetcode35 - Search Insert Position - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc75&quot;&gt;0611 - Leetcode75 - Sorting Colors - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc380&quot;&gt;0612 - Leetcode380 - Insert Delete GetRandom O(1) - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc368&quot;&gt;0613 - Leetcode368 - Largest Divisible Subset - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc300&quot;&gt;补充 - Leetcode300 - Longest Increasing Subsequence - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc787&quot;&gt;0614 - Leetcode787 - Cheapest Flights within K stops - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc700&quot;&gt;0615 - Leetcode700 - Search in a Binary Search Tree - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc468&quot;&gt;0616 - Leetcode468 - Validate IP Address - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc130&quot;&gt;0617 - Leetcode130 - Surrounded Regions - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc200&quot;&gt;补充 - Leetcode200 - Number of Islands - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc547&quot;&gt;补充 - Leetcode547 - Friend Circles - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc275&quot;&gt;0618 - Leetcode275 - H-index II - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc1044&quot;&gt;0619 - Leetcode1044 - Longest Duplicate Substring - Hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc60&quot;&gt;0620 - Leetcode60 - Permutation Sequence - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc31&quot;&gt;补充 - Leetcode31 - Next Permutation - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc46&quot;&gt;补充 - Leetcode46 - Permutations - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc174&quot;&gt;0621 - Leetcode174 - Dungeon Games - Hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc137&quot;&gt;0622 - Leetcode137 - Single Number II - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc136&quot;&gt;补充 - Leetcode136 - Single Number I - Easy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc260&quot;&gt;补充 - Leetcode260 - Single Number III - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc222&quot;&gt;0623 - Leetcode222 - Count Complete Tree Node - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc96&quot;&gt;0624 - Leetcode96 - Unique Binary Search Trees - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc95&quot;&gt;补充 - Leetcode95 -Unique Binary Search Trre II - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc287&quot;&gt;0625 - Leetcode287 - Find the Duplicate Number - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc142&quot;&gt;补充 - Leetcode142 - Linked List Cycle II - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc129&quot;&gt;0626 - Leetcode129 - Sum Root to Leaf Number - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc279&quot;&gt;0627 - Leetcode279 - Perfect squares - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc322&quot;&gt;0628 - Leetcode322 - Reconstruct Itenerary - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc62&quot;&gt;0629 - Leetcode62 - Unique Paths - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc63&quot;&gt;补充 - Leetcode63 - Unique Paths II - Medium&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc212&quot;&gt;0630 - Leetcode212 - Word Search II - Hard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#lc74&quot;&gt;补充 - Leetcode79 - Word Search I - Medium&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>whatidid | 提取CCL双语语料检索库检索数据</title>
    <link href="http://yoursite.com/2020/05/16/whatidid-%E6%8F%90%E5%8F%96CCL%E8%AF%AD%E6%96%99%E6%A3%80%E7%B4%A2%E5%BA%93%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2020/05/16/whatidid-%E6%8F%90%E5%8F%96CCL%E8%AF%AD%E6%96%99%E6%A3%80%E7%B4%A2%E5%BA%93%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/</id>
    <published>2020-05-16T22:59:00.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>提取CCL双语语料库信息【简易网页内容抓取】</p><p>说明：此程序非商用，纯属个人提取数据时写的简单的抓取网页信息的程序，具体内容请参阅 <a href="http://ccl.pku.edu.cn:8080/ccl_corpus/CCLCorpus_Readme.html">CCL语料库使用说明</a> 。感谢CCL语料库的创建和维护者。<strong>转载请标明出处</strong></p><p>适用范围：CCL双语语料库</p><p>输入信息：查询词汇query，词汇左右两边限定词汇长度max_left, max_right</p><p>返回内容：无 (会在当前文件夹下创建 ./CCL_corpus/ 文件夹保存目标词汇的搜索结果)</p><p>图片说明：</p><p><img src="/images/3281589670804_.pic_hd.jpg" alt="3281589670804_.pic_hd"><img src="/images/3291589670915_.pic_hd.jpg" alt="3291589670915_.pic_hd"></p><p>具体程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_sentences</span>(<span class="params">query:<span class="built_in">str</span>=<span class="string">&#x27;bill&#x27;</span>, max_left:<span class="built_in">int</span>=<span class="number">300</span>, max_right:<span class="built_in">int</span>=<span class="number">300</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param query: 目标搜索词 target word</span></span><br><span class="line"><span class="string">    :param max_left: 左侧提取最多字数(以char为单位) maximum str length before target word</span></span><br><span class="line"><span class="string">    :param max_right: 右侧提取最多字数(以char为单位)minmum str length after target word</span></span><br><span class="line"><span class="string">    :return: None. (Generate the file containing sentences)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    page = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        web = <span class="string">&#x27;http://ccl.pku.edu.cn:8080/ccl_corpus/search?dir=chen&amp;q=&#x27;</span>+query+<span class="string">&#x27;&amp;LastQuery=&#x27;</span>+query+<span class="string">&#x27;&amp;start=&#x27;</span>+<span class="built_in">str</span>((page<span class="number">-1</span>)*<span class="number">50</span>)+<span class="string">&#x27;&amp;num=50&#x27;</span>+\</span><br><span class="line">              <span class="string">&#x27;&amp;index=FullIndex&amp;outputFormat=HTML&amp;orderStyle=score&amp;encoding=UTF-8&amp;neighborSortLength=0&amp;maxLeftLength=&#x27;</span>+<span class="built_in">str</span>(max_left)+<span class="string">&#x27;&amp;maxRightLength=&#x27;</span>+<span class="built_in">str</span>(max_right)+<span class="string">&#x27;&amp;isForReading=yes&#x27;</span></span><br><span class="line">        response = requests.get(web)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> response.raise_for_status(): <span class="comment"># check if the website is available</span></span><br><span class="line">            print(response.raise_for_status())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        url_text = response.content.decode()</span><br><span class="line"></span><br><span class="line">        se = re.search(</span><br><span class="line">            <span class="string">r&#x27;&lt;td width=\&quot;3%\&quot;&gt;(\d+)&lt;\/td&gt;&lt;td width=\&quot;45%\&quot; valign=\&quot;top\&quot; colspan=\&quot;3\&quot; align=\&quot;left\&quot;&gt;(.+?)&lt;\/td&gt;&lt;td width=\&quot;45%\&quot; valign=\&quot;top\&quot; colspan=\&quot;3\&quot; align=\&quot;left\&quot;&gt;(.+?)&lt;\/td&gt;&lt;\/tr&gt;&#x27;</span>,</span><br><span class="line">            url_text, re.S)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> se: <span class="comment"># If there is no matching pattern, break</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        match = re.finditer(<span class="string">r&#x27;&lt;td width=\&quot;3%\&quot;&gt;(\d+)&lt;\/td&gt;&lt;td width=\&quot;45%\&quot; valign=\&quot;top\&quot; colspan=\&quot;3\&quot; align=\&quot;left\&quot;&gt;(.+?)&lt;\/td&gt;&lt;td width=\&quot;45%\&quot; valign=\&quot;top\&quot; colspan=\&quot;3\&quot; align=\&quot;left\&quot;&gt;(.+?)&lt;\/td&gt;&lt;\/tr&gt;&#x27;</span>,</span><br><span class="line">                                url_text, re.S)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">&#x27;../CCL_corpus&#x27;</span>):</span><br><span class="line">            os.mkdir(<span class="string">&#x27;../CCL_corpus&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;../CCL_corpus/ccl_&#x27;</span>+query+<span class="string">&#x27;.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> match:</span><br><span class="line"></span><br><span class="line">                f.write(m.group(<span class="number">1</span>)+<span class="string">&#x27; &#x27;</span>+ re.sub(<span class="string">&#x27; +&#x27;</span>, <span class="string">&#x27; &#x27;</span>, re.sub(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>, m.group(<span class="number">2</span>)))+<span class="string">&#x27; &#x27;</span>+</span><br><span class="line">                        re.sub(<span class="string">&#x27; +&#x27;</span>, <span class="string">&#x27; &#x27;</span>, re.sub(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>, m.group(<span class="number">3</span>)))+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        page += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    target_words_list = [<span class="string">&#x27;address&#x27;</span>, <span class="string">&#x27;appreciate&#x27;</span>, <span class="string">&#x27;beat&#x27;</span>, <span class="string">&#x27;bill&#x27;</span>, <span class="string">&#x27;bond&#x27;</span>, <span class="string">&#x27;column&#x27;</span>, <span class="string">&#x27;cover&#x27;</span>, <span class="string">&#x27;deliver&#x27;</span>, <span class="string">&#x27;exploit&#x27;</span>, <span class="string">&#x27;figure&#x27;</span>,<span class="string">&#x27;perspective&#x27;</span>, <span class="string">&#x27;platform&#x27;</span>, <span class="string">&#x27;provision&#x27;</span>, <span class="string">&#x27;rest&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> target_words_list:</span><br><span class="line">        extract_sentences(t)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提取CCL双语语料库信息【简易网页内容抓取】&lt;/p&gt;
&lt;p&gt;说明：此程序非商用，纯属个人提取数据时写的简单的抓取网页信息的程序，具体内容请参阅 &lt;a href=&quot;http://ccl.pku.edu.cn:8080/ccl_corpus/CCLCorpus_Readme.h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂学 | 对于Word2Vec的一点理解</title>
    <link href="http://yoursite.com/2020/04/19/whatidid-gensim-word2vec-doc/"/>
    <id>http://yoursite.com/2020/04/19/whatidid-gensim-word2vec-doc/</id>
    <published>2020-04-19T19:53:08.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>解读Gensim中Word2Vec Model，<a href="https://radimrehurek.com/gensim/auto_examples/tutorials/run_word2vec.html#sphx-glr-download-auto-examples-tutorials-run-word2vec-py">文档</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;解读Gensim中Word2Vec Model，&lt;a href=&quot;https://radimrehurek.com/gensim/auto_examples/tutorials/run_word2vec.html#sphx-glr-download-auto-example</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Machine-Learning-2020 | Lecture#3 Deep Learning 预备知识</title>
    <link href="http://yoursite.com/2020/04/14/Machine-Learning-2020-Week-4-Deep-Learning-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/04/14/Machine-Learning-2020-Week-4-Deep-Learning-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/</id>
    <published>2020-04-14T15:28:00.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对Deep-Learning的简介"><a href="#对Deep-Learning的简介" class="headerlink" title="对Deep Learning的简介"></a>对Deep Learning的简介</h1><p>简单来说，Deep Learning的发展从最早的Perceptron开始一直到现在的蓬勃发展也是经历了很多。</p><p>就像之前说的，在做Machine Learning的时候，分为3步，Deep Learning也是一样。</p><ol><li>Define Function sets 这里的function sets就是neural network，因为neural network中参数不同，所以这些是一系列的方程集。</li><li>Goodness of function 在寻找比较适合模型的参数的时候，我们找到的评价模型的是损失函数。根绝不同的任务，会有不同的损失函数</li><li>Minimize loss function 无论我们最终应用的损失函数是什么，我们最终的目的都是最小化损失函数。在最小化的过程中我们可以用到一些优化的方法。</li></ol><p>在之前的分类和回归的任务中，我们所做的基本上都是一层网络。在regression任务中，是输入数据经过一个参数方程然后得到输出；在classfication任务中，是输入经过一个参数方程，再经过一个sigmoid方程进行分类。</p><p>但有时候，只通过一个参数方程无法满足我们复杂的需求，所以神经网络就是让这些参数方程横向变多，纵向变厚。我们通过计算不同的参数方程，再结合不同参数方程的结果得到我们最终想要的分类或回归结果。</p><p>这些中间不断生成和组合的层就叫做Hidden Layers，结合了很多隐藏层的网络就被称为深度网络。</p><p>目前我我们可以用很多框架（tensorflow，pytorch等）来实现深度神经网络的搭建和计算。</p><h2 id="BackPropagation"><a href="#BackPropagation" class="headerlink" title="BackPropagation"></a>BackPropagation</h2><p>其实在之前我们提到的梯度下降和Backpropagation差不多, 差别是BackPropagation所涉及的参数和流程更为复杂, 因为在Neural Network中存在的参数更多。</p><p>在linear regression和logistic regression中，我们更新参数的步骤很简单，因为预测的结果很简单，可以可以直接用feature $\bf x$ 乘以各自的权重 $\bf w$ 得到预测值 $\bf y = xw$，所以我们在更新参数 $\bf w$ 的时候只用一步计算$\bf w = w - \frac{\part L(w)}{\part w}$参数对结果的导数，然后就可以更新了，但是Neural Network的参数有很多，而且有很多层。</p><p>我们先来看一下NeuralNetwork的结构：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;对Deep-Learning的简介&quot;&gt;&lt;a href=&quot;#对Deep-Learning的简介&quot; class=&quot;headerlink&quot; title=&quot;对Deep Learning的简介&quot;&gt;&lt;/a&gt;对Deep Learning的简介&lt;/h1&gt;&lt;p&gt;简单来说，Deep </summary>
      
    
    
    
    <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="lecture notes" scheme="http://yoursite.com/tags/lecture-notes/"/>
    
    <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
    <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
    <category term="Backpropagation" scheme="http://yoursite.com/tags/Backpropagation/"/>
    
  </entry>
  
  <entry>
    <title>Machine-Learning-2020| Lecture #2 New Optimization</title>
    <link href="http://yoursite.com/2020/04/13/Machine-Learning-2020-Lecture-2-New-Optimization/"/>
    <id>http://yoursite.com/2020/04/13/Machine-Learning-2020-Lecture-2-New-Optimization/</id>
    <published>2020-04-13T17:08:51.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这部分介绍的是对于当前大家在做深度学习用到的optimization的几种方法的总结介绍以及改进的方面。首先会介绍常用的几种optimization的方法，然后是对现行几种方法的总结和优劣势分析。</p><h1 id="标注说明"><a href="#标注说明" class="headerlink" title="标注说明"></a>标注说明</h1><ul><li>$\theta_t$ 表示时刻 $t$ 的参数值。这个参数就是我们要训练的模型中的参数集合；</li><li>$\Delta L(\theta_t) / g_t$ 表示时刻 $t$ 参数的gradient，这个是我们在更新参数时需要用到的；</li><li>$m_t$ 表示截止到 $t$ 时刻，之前累积的 momentum的和</li><li>$\eta$ 表示学习率</li></ul><h1 id="常见的Optimization回顾"><a href="#常见的Optimization回顾" class="headerlink" title="常见的Optimization回顾"></a>常见的Optimization回顾</h1><ul><li><p>SGD（stochastic gradient descent）</p><p>这里说的是随机梯度下降，也就是输入一个example之后就对这个example的梯度进行计算，然后根据公式</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_{t}-\eta g_t</script><p>表示模型中的参数会根据本次的梯度，在固定学习率$\eta$ 的状态下进行变化。</p></li><li><p>SGDM （stochastic gradient descent with momentum）</p><p>这里说的是在之前随机梯度下降的基础上加上了对梯度的改进，也就是加上了Momentum对梯度的影响:</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_{t} + v_t\\ v_t = \lambda v_{t-1} - \eta g_t</script><p>这里若是将 $v<em>t$ 带回第一个公式中，就变为 $\theta</em>{t+1} = \theta<em>{t}-\eta g_t + \lambda v</em>{t-1}$, 和SGD的公式比起来，多加了一项 $\lambda v_{t-1}$ 这项是之前的momentum的历史。</p></li><li><p>Adagrad</p><p>最理想的学习率的变化是在一开始学习的时候，学习率会比较大，这样的话可以减少寻找最佳位置的时间，但是随着我们寻找越接近最佳的点，学习率需要变小，这样的话不至于一步错过需要找寻的点。所以我们希望学习率会随着时间的变化减小，即 $\eta_t = \frac{\eta}{\sqrt{t+1}}$.</p><p>但只做这点改变是不够的的，即使我们对学习率做了变化，它也是随着时间的变化。对于不同的参数，学习率的变化量仍旧是个定值。我们期望学习率能够在自己参数本身变化的情况下进行改变，也就是说有些参数变化的波动大，有些参数变化的波动小，我们希望学习率能根据参数本身做出变化。</p><p>因此, 我们希望考虑过去所有计算过的梯度:</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_{t} - \frac{\eta_t}{\sqrt{\frac{1}{t+1}\sum\limits_{i = 0}^{t} g_i^2}}g_t = \theta_{t} - \frac{\eta}{\sqrt{\sum\limits_{i = 0}^{t} g_i^2}}g_t</script></li><li><p>RMSProp</p><p>当我们在进行Adagrad的时候，分母的梯度平方和会不停累计变大，如果在一开始我们遇到了一个比较大的梯度，那么会造成</p><p>我们考虑的梯度变化公式为：</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{v_{t+1}}}g_t\\ v_t = \alpha v_{t-1} +(1 - \alpha)g_{t-1}^2</script><p>如果将第二个式子带入梯度更新的式子中去，我们会得到:</p><script type="math/tex; mode=display">v_{t+1} = (1-\alpha)g_{t}^2 + \alpha(1 - \alpha)g_{t-1}^2 + \alpha^2(1-\alpha)g_{t-2}^2+...</script><p>这样就可以得到，当 $\alpha$ 的值很小的时候，学习率的分母将会只记住和现在时刻离得比较近的梯度值，时间比较靠前的梯度值都被 $\alpha^n$ 给消去了。</p></li><li><p>Adam</p><p>最后来说一下Adam，Adam是结合了SGDM 和 RMSProp的方法。</p><p>主要的更新公式为：</p><script type="math/tex; mode=display">\theta_{t+1} = \theta_t - \frac{\eta}{\sqrt{\hat v_{t+1}}+\epsilon}\hat m_{t+1}\\ \hat m_{t+1} = \frac{m_{t+1}}{1 - \beta_1^{t+1}}\\ \hat v_{t+1} = \frac{v_{t+1}}{1 - \beta_1^{t+1}}</script><p>$m_t$ 的部分就是采用了之前SGDM对梯度的改变，而 $v_t$ 的部分采用的是RMSProp对学习率的改变。</p></li></ul><h2 id="对于SGDM和Adam的改进"><a href="#对于SGDM和Adam的改进" class="headerlink" title="对于SGDM和Adam的改进"></a>对于SGDM和Adam的改进</h2><p>在神经网络急速发展的现在，我们除了上述的几种optimization之外，还记过什么其他别的optimization的方法吗？有，但是很少。在计算机视觉任务中，我们常见到的就是Adam优化方法，和SGD优化方法。其他的很少见也很少尝试，那究竟是为什么呢？</p><p>因为SGDM和Adam占尽了先机。我们说，普通的梯度下降 $\theta<em>{t+1} = \theta</em>{t}-\eta g_t$， 在这其中，影响梯度下降的两个因素，一个就是学习率 $\eta$ 另一个就是 梯度 $g_t$。 SGD包括SGDM可以说是对梯度做了调整，而Ada-系是调整了学习率。所以这两种方法从两个方面改进了梯度下降时的自我调整水平。</p><p>但是SGDM和Adam分别有各自的优缺点：</p><ul><li>SGDM在训练的时候下降比较慢，训练集上的精度没有Adam高，但是测试集上的精度会比较高</li><li>Adam在训练的时候下井比较迅速且精度较高，但是在测试时达到的精度不是很高。</li></ul><p>那大家就像根据SGDM和Adam各自的优点和缺点来进行改进。</p><h2 id="针对SGDM进行改进"><a href="#针对SGDM进行改进" class="headerlink" title="针对SGDM进行改进"></a>针对SGDM进行改进</h2><h2 id="针对Adam进行改进"><a href="#针对Adam进行改进" class="headerlink" title="针对Adam进行改进"></a>针对Adam进行改进</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这部分介绍的是对于当前大家在做深度学习用到的optimization的几种方法的总结介绍以及改进的方面。首先会介绍常用的几种optimization的方法，然后是对现行几种方法的总结和优劣势分析。&lt;/p&gt;
&lt;h1 id=&quot;标注说明&quot;&gt;&lt;a href=&quot;#标注说明&quot; clas</summary>
      
    
    
    
    <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="lecture notes" scheme="http://yoursite.com/tags/lecture-notes/"/>
    
    <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
    <category term="Optimization" scheme="http://yoursite.com/tags/Optimization/"/>
    
  </entry>
  
  <entry>
    <title>杂学 | 【百度PaddlePaddle】深度学习7日入门-CV疫情专题</title>
    <link href="http://yoursite.com/2020/04/12/whatidid-%E3%80%90%E7%99%BE%E5%BA%A6PaddlePaddle%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A07%E6%97%A5%E5%85%A5%E9%97%A8-CV%E7%96%AB%E6%83%85%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/12/whatidid-%E3%80%90%E7%99%BE%E5%BA%A6PaddlePaddle%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A07%E6%97%A5%E5%85%A5%E9%97%A8-CV%E7%96%AB%E6%83%85%E4%B8%93%E9%A2%98/</id>
    <published>2020-04-12T21:28:27.000Z</published>
    <updated>2020-09-24T19:51:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【百度PaddlePaddle】深度学习7日入门-CV疫情"><a href="#【百度PaddlePaddle】深度学习7日入门-CV疫情" class="headerlink" title="【百度PaddlePaddle】深度学习7日入门-CV疫情"></a>【百度PaddlePaddle】深度学习7日入门-CV疫情</h1><p>本文件夹为百度Aistudio课程《深度学习7日入门-CV疫情》</p><ul><li>数据： 从百度Aistudio数据集下载</li><li>框架： PaddlePaddle</li><li>语言： Python</li></ul><p>作业调试详解及心得体会请参照各作业文件夹。</p><h2 id="1-数据可视化-已完成"><a href="#1-数据可视化-已完成" class="headerlink" title="1. 数据可视化[已完成])"></a>1. 数据可视化<a href="(https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/HW1">[已完成]</a>)</h2><p>基于 <a href="https://ncov.dxy.cn/ncovh5/view/pneumonia">丁香园</a> 整合全国疫情数据更新制作可视化数据图。</p><p>作业任务：</p><pre><code> 1. 下载安装 PaddlePaddle，课程中有详细介绍 2. 应用学习pyecharts库学习应用，将全国疫情数据可视化在饼状图中</code></pre><p>作业举例：</p><pre><code>1. 已提供爬虫script，将丁香园中的数据下载整合到本地2. 已提供pyecharts部分地图和趋势图的实现代码</code></pre><h2 id="2-构建DNN神经网络手势识别-已完成"><a href="#2-构建DNN神经网络手势识别-已完成" class="headerlink" title="2. 构建DNN神经网络手势识别[已完成)]"></a>2. 构建DNN神经网络手势识别[<a href="(https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/HW2">已完成</a>)]</h2><p>基于DNN全连接神经网络对手势和对应数字进行识别。</p><p>作业任务：</p><pre><code> 1. 完成DNN 神经网络 2. 优化自己的DNN神经网络(test_acc:0.83, SGD, lr = 0.001, epoch = 200)</code></pre><h2 id="3-构建CNN神经网络车牌识别-已完成"><a href="#3-构建CNN神经网络车牌识别-已完成" class="headerlink" title="3. 构建CNN神经网络车牌识别[已完成)]"></a>3. 构建CNN神经网络车牌识别[<a href="(https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/HW3">已完成</a>)]</h2><p>基于CNN卷积神经网络对车牌的(数字/ 字母/ 省简称)进行识别</p><p>作业任务：</p><pre><code> 1. 完成CNN神经网络 2. 优化自己的CNN神经网络(test_acc:0.93, SGD, lr 0.01, epoch = 200)</code></pre><h2 id="4-模块化构建VGG神经网络口罩识别-已完成"><a href="#4-模块化构建VGG神经网络口罩识别-已完成" class="headerlink" title="4. 模块化构建VGG神经网络口罩识别[已完成)]"></a>4. 模块化构建VGG神经网络口罩识别[<a href="(https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/HW4">已完成</a>)]</h2><p>定义重复出现的CNN网络结构使其模块化，二分类识别图片中的人是否戴口罩。（更完整的完成任务还需要识别图片中人脸的位置）</p><p>作业任务：</p><pre><code>1. 完成CNN神经网络2. 优化自己的CNN神经网络（+BatchNorm test_acc=1.0, Adam, lr = 0.0001, epoch=50）</code></pre><h2 id="5-Paddle-Slim-对模型进行精简-已完成"><a href="#5-Paddle-Slim-对模型进行精简-已完成" class="headerlink" title="5. Paddle Slim 对模型进行精简[已完成]"></a>5. Paddle Slim 对模型进行精简[已完成]</h2><p>学习实践Paddle Slim对模型精简模块，可以有效提高模型速度，减小模型所占内存。</p><p>作业任务：</p><pre><code>1. 概念选择题2. 完成定点量化精简</code></pre><h2 id="比赛：人流密度检测-得分：0-49469分-排名：51-368-已完成-https-github-com-Capchenxi-Aistudio-tree-master-深度学习7日入门-CV疫情特辑-Compete"><a href="#比赛：人流密度检测-得分：0-49469分-排名：51-368-已完成-https-github-com-Capchenxi-Aistudio-tree-master-深度学习7日入门-CV疫情特辑-Compete" class="headerlink" title="比赛：人流密度检测[得分：0.49469分 排名：51/368] [已完成][(https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/Compete)]"></a>比赛：人流密度检测[得分：0.49469分 排名：51/368] [已完成][(<a href="https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/Compete">https://github.com/Capchenxi/Aistudio/tree/master/深度学习7日入门-CV疫情特辑/Compete</a>)]</h2><p>比赛任务:检测人流密度，得分应该是错误率之类的，越低越好。<br>训练数据：常规赛-人流密度检测<br>试验方法：</p><ul><li>Baseline: 老师给出的baseline就已经了不起了，跑通了大概能排到200+左右目前，单纯的cnn放在一起提取的人流密度热力图。的粉黛该是0.68左右</li><li>我的方法：参考了 <a href="https://arxiv.org/pdf/1906.09707.pdf">Dense Scale Network for Crowd Counting</a> 这篇文章中密集的残差连接结构，除了MSE作为loss之外还加入了不同尺度下的MAE（mean absolute error）作为loss。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;【百度PaddlePaddle】深度学习7日入门-CV疫情&quot;&gt;&lt;a href=&quot;#【百度PaddlePaddle】深度学习7日入门-CV疫情&quot; class=&quot;headerlink&quot; title=&quot;【百度PaddlePaddle】深度学习7日入门-CV疫情&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="干货" scheme="http://yoursite.com/categories/%E5%B9%B2%E8%B4%A7/"/>
    
    
    <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="PaddlePaddle" scheme="http://yoursite.com/tags/PaddlePaddle/"/>
    
  </entry>
  
  <entry>
    <title>PaperReading | BERT:Pre-training of Deep Bidirectional Transformers for Language Understanding</title>
    <link href="http://yoursite.com/2020/04/09/PaperReading-BERT-Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding/"/>
    <id>http://yoursite.com/2020/04/09/PaperReading-BERT-Pre-training-of-Deep-Bidirectional-Transformers-for-Language-Understanding/</id>
    <published>2020-04-10T01:59:10.000Z</published>
    <updated>2020-09-24T19:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>我们介绍了一个新的语言表达模型叫做 BERT （Bidirectional-Encoder-Representations from Transformers）.和最近出现的语言表达模型不同， Bert是基于前后上下文来预训练深度双向表达未标注文本的。所以说，预训练BERT模型可以通过只增加一个输出层来调优以便得到适用于各种任务的最佳模型。</p><p>BERT is conceptually simple and empirically powerful. 从理论和实践上来讲，BERT很强大。他得到了新的GLUE高分。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;我们介绍了一个新的语言表达模型叫做 BERT （Bidirectional-Encoder-Representations from Tra</summary>
      
    
    
    
    
  </entry>
  
</feed>
