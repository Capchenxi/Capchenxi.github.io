<!DOCTYPE html>
<html lang="zh-Hans,en,zh_CN,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta name="description" content="【LeetCode】- June Challenge 0606 - Leetcode1029 - Two City Scheduling - Easy 0607 - Leetcode518 - Coin Change 2 - Medium 补充 - Leetcode322 - Coin Change - Medium 0608 - Leetcode231-Power Of Two - Easy 0">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm | LeetCode - June Challenge">
<meta property="og:url" content="http://yoursite.com/2020/06/06/Algorithm-Leetcode-June%20Challenge/index.html">
<meta property="og:site_name" content="光">
<meta property="og:description" content="【LeetCode】- June Challenge 0606 - Leetcode1029 - Two City Scheduling - Easy 0607 - Leetcode518 - Coin Change 2 - Medium 补充 - Leetcode322 - Coin Change - Medium 0608 - Leetcode231-Power Of Two - Easy 0">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/Note%20Jun%206,%202020-2274380.jpeg">
<meta property="og:image" content="http://yoursite.com/images/Note%20Jun%206,%202020-2.jpeg">
<meta property="article:published_time" content="2020-06-07T03:31:47.000Z">
<meta property="article:modified_time" content="2020-06-07T03:31:47.000Z">
<meta property="article:author" content="Chenxi">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/Note%20Jun%206,%202020-2274380.jpeg">


<link rel="canonical" href="http://yoursite.com/2020/06/06/Algorithm-Leetcode-June%20Challenge/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Algorithm | LeetCode - June Challenge | 光</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="光" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">光</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Life sucks, but you're gonna love it.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0630-Leetcode79-Word-Search-II"><span class="nav-number">1.</span> <span class="nav-text">0630 - Leetcode79 - Word Search II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0629-Leetcode62-Unique-Paths"><span class="nav-number">2.</span> <span class="nav-text">0629 - Leetcode62 - Unique Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode63-Unique-Paths-II"><span class="nav-number">3.</span> <span class="nav-text">补充 - Leetcode63 - Unique Paths II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0628-Leetcode322-Reconstruct-Itenerary"><span class="nav-number">4.</span> <span class="nav-text">0628 - Leetcode322 - Reconstruct Itenerary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0627-Leetcode279-Perfect-squares"><span class="nav-number">5.</span> <span class="nav-text">0627 - Leetcode279 - Perfect squares</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0626-Leetcode127-Sum-Root-to-Leaf-Number"><span class="nav-number">6.</span> <span class="nav-text">0626 - Leetcode127 - Sum Root to Leaf Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0625-Leetcode287-Find-the-Duplicate-Number"><span class="nav-number">7.</span> <span class="nav-text">0625 - Leetcode287 - Find the Duplicate Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode142-Linked-List-Cycle-II"><span class="nav-number">8.</span> <span class="nav-text">补充 - Leetcode142 - Linked List Cycle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0624-Leetcode96-Unique-Binary-Search-Trees"><span class="nav-number">9.</span> <span class="nav-text">0624 - Leetcode96 - Unique Binary Search Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode95-Unique-Binary-Search-Tree-II"><span class="nav-number">10.</span> <span class="nav-text">补充 - Leetcode95 - Unique Binary Search Tree II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0623-Leetcod222-Count-Complete-Tree-Node"><span class="nav-number">11.</span> <span class="nav-text">0623 - Leetcod222 - Count Complete Tree Node</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0622-Leetcode137-Single-Number-II"><span class="nav-number">12.</span> <span class="nav-text">0622 - Leetcode137 - Single Number II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode136-Single-Number-I"><span class="nav-number">13.</span> <span class="nav-text">补充 - Leetcode136 - Single Number I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode260-Single-Number-III"><span class="nav-number">14.</span> <span class="nav-text">补充 - Leetcode260 - Single Number III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0621-Leetcode174-Dungeon-Games"><span class="nav-number">15.</span> <span class="nav-text">0621 - Leetcode174 - Dungeon Games</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0620-Leetcode60-Permuation-Sequence"><span class="nav-number">16.</span> <span class="nav-text"> 0620 - Leetcode60 - Permuation Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode31-Next-Permutation"><span class="nav-number">17.</span> <span class="nav-text"> 补充 - Leetcode31 - Next Permutation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0619-Leetcode1044-Longest-Duplicate-Substring"><span class="nav-number">18.</span> <span class="nav-text"> 0619 - Leetcode1044 - Longest Duplicate Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0618-Leetcode275-H-index-II"><span class="nav-number">19.</span> <span class="nav-text"> 0618 - Leetcode275 - H-index II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0617-Leetcode130-Surrounded-Regions"><span class="nav-number">20.</span> <span class="nav-text"> 0617 - Leetcode130 - Surrounded Regions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode200-Number-of-Islands"><span class="nav-number">21.</span> <span class="nav-text">补充 - Leetcode200 - Number of Islands</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode547-Friend-Circles"><span class="nav-number">22.</span> <span class="nav-text"> 补充 - Leetcode547 - Friend Circles</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0616-Leetcode468-Validate-IP-Address"><span class="nav-number">23.</span> <span class="nav-text"> 0616 - Leetcode468 - Validate IP Address</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0615-Leetcode700-Search-in-a-binary-tree"><span class="nav-number">24.</span> <span class="nav-text"> 0615 - Leetcode700 - Search in a binary tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0614-Leetcode787-Cheapest-Flights-within-K-stops"><span class="nav-number">25.</span> <span class="nav-text"> 0614 - Leetcode787 - Cheapest Flights within K stops.</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0613-Leetcode368-Largest-Divisible-Subset"><span class="nav-number">26.</span> <span class="nav-text">0613 - Leetcode368 - Largest Divisible Subset</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode300-Longest-Increasing-Subsequence"><span class="nav-number">27.</span> <span class="nav-text">补充 - Leetcode300 - Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0611-Leetcode75-Sorting-Colors-Medium"><span class="nav-number">28.</span> <span class="nav-text"> 0611 - Leetcode75 - Sorting Colors - Medium</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0610-Leetcode35-Search-Insert-Position-Easy"><span class="nav-number">29.</span> <span class="nav-text"> 0610 - Leetcode35 - Search Insert Position - Easy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0609-Leetcode392-Is-Subsequence"><span class="nav-number">30.</span> <span class="nav-text"> 0609 - Leetcode392 - Is Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-Leetcode115-Distinct-Subsequence-Hard"><span class="nav-number">31.</span> <span class="nav-text"> 补充 - Leetcode115 - Distinct Subsequence - Hard</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0608-Leetcode231-Power-Of-Two-Easy"><span class="nav-number">32.</span> <span class="nav-text"> 0608 - Leetcode231-Power Of Two - Easy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0607-Leetcode518-Coin-Change-2"><span class="nav-number">33.</span> <span class="nav-text"> 0607 - Leetcode518 - Coin Change 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85-LeetCode322-Coin-Change"><span class="nav-number">34.</span> <span class="nav-text"> 补充 - LeetCode322 - Coin Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0606-Leetcode1029-Two-City-Scheduling-Easy"><span class="nav-number">35.</span> <span class="nav-text"> 0606 - Leetcode1029 - Two City Scheduling - Easy</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chenxi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/06/Algorithm-Leetcode-June%20Challenge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chenxi">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="光">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Algorithm | LeetCode - June Challenge
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-06-06 23:31:47" itemprop="dateCreated datePublished" datetime="2020-06-06T23:31:47-04:00">2020-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>【LeetCode】- June Challenge</p>
<p><a href="#lc1029">0606 - Leetcode1029 - Two City Scheduling - Easy</a></p>
<p><a href="#lc518">0607 - Leetcode518 - Coin Change 2 - Medium</a></p>
<p><a href="#lc322">补充 - Leetcode322 - Coin Change - Medium</a></p>
<p><a href="#lc231">0608 - Leetcode231-Power Of Two - Easy</a></p>
<p><a href="#lc392">0609 - Leetcode392 - Is Subsequence - Easy</a></p>
<p><a href="#lc115">补充 - Leetcode115 - Distinct Subsequence - Hard</a></p>
<p><a href="#lc35">0610 - Leetcode35 - Search Insert Position - Easy</a></p>
<p><a href="#lc75">0611 - Leetcode75 - Sorting Colors - Medium</a></p>
<p><a href="#lc380">0612 - Leetcode380 - Insert Delete GetRandom O(1) - Medium</a></p>
<p><a href="#lc368">0613 - Leetcode368 - Largest Divisible Subset - Medium</a></p>
<p><a href="#lc300">补充 - Leetcode300 - Longest Increasing Subsequence - Medium</a></p>
<p><a href="#lc787">0614 - Leetcode787 - Cheapest Flights within K stops - Medium</a></p>
<p><a href="#lc700">0615 - Leetcode700 - Search in a Binary Search Tree - Easy</a></p>
<p><a href="#lc468">0616 - Leetcode468 - Validate IP Address - Medium</a></p>
<p><a href="#lc130">0617 - Leetcode130 - Surrounded Regions - Medium</a></p>
<p><a href="#lc200">补充 - Leetcode200 - Number of Islands - Medium</a></p>
<p><a href="#lc547">补充 - Leetcode547 - Friend Circles - Medium</a></p>
<p><a href="#lc275">0618 - Leetcode275 - H-index II - Medium</a></p>
<p><a href="#lc1044">0619 - Leetcode1044 - Longest Duplicate Substring - Hard</a></p>
<p><a href="#lc60">0620 - Leetcode60 - Permutation Sequence - Medium</a></p>
<p><a href="#lc31">补充 - Leetcode31 - Next Permutation - Medium</a></p>
<p><a href="#lc46">补充 - Leetcode46 - Permutations - Medium</a></p>
<p><a href="#lc174">0621 - Leetcode174 - Dungeon Games - Hard</a></p>
<p><a href="#lc137">0622 - Leetcode137 - Single Number II - Medium</a></p>
<p><a href="#lc136">补充 - Leetcode136 - Single Number I - Easy</a></p>
<p><a href="#lc260">补充 - Leetcode260 - Single Number III - Medium</a></p>
<p><a href="#lc222">0623 - Leetcode222 - Count Complete Tree Node - Medium</a></p>
<p><a href="#lc96">0624 - Leetcode96 - Unique Binary Search Trees - Medium</a></p>
<p><a href="#lc95">补充 - Leetcode95 -Unique Binary Search Trre II - Medium</a></p>
<p><a href="#lc287">0625 - Leetcode287 - Find the Duplicate Number - Medium</a></p>
<p><a href="#lc142">补充 - Leetcode142 - Linked List Cycle II - Medium</a></p>
<p><a href="#lc129">0626 - Leetcode129 - Sum Root to Leaf Number - Medium</a></p>
<p><a href="#lc279">0627 - Leetcode279 - Perfect squares - Medium</a></p>
<p><a href="#lc322">0628 - Leetcode322 - Reconstruct Itenerary - Medium</a></p>
<p><a href="#lc62">0629 - Leetcode62 - Unique Paths - Medium</a></p>
<p><a href="#lc63">补充 - Leetcode63 - Unique Paths II - Medium</a></p>
<p><a href="#lc212">0630 - Leetcode212 - Word Search II - Hard</a></p>
<p><a href="#lc74">补充 - Leetcode79 - Word Search I - Medium</a></p>
<a id="more"></a>
<p>-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=</p>
<h1 id="0630-Leetcode79-Word-Search-II"><a href="#0630-Leetcode79-Word-Search-II" class="headerlink" title="0630 - Leetcode79 - Word Search II"></a>0630 - Leetcode79 - Word Search II</h1><blockquote>
<p>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<p><strong>Example:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">board = [</span><br><span class="line">  [&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;,&#x27;n&#x27;],</span><br><span class="line">  [&#x27;e&#x27;,&#x27;t&#x27;,&#x27;a&#x27;,&#x27;e&#x27;],</span><br><span class="line">  [&#x27;i&#x27;,&#x27;h&#x27;,&#x27;k&#x27;,&#x27;r&#x27;],</span><br><span class="line">  [&#x27;i&#x27;,&#x27;f&#x27;,&#x27;l&#x27;,&#x27;v&#x27;]</span><br><span class="line">]</span><br><span class="line">words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line"></span><br><span class="line">Output: [&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>DFS ： 纯DFS就和后面word search I 是一样的，只不过这里给出了一个list的单词，我们需要针对这个list里面所有的单词来找。这个方法刚才在python里面尝试是超过时间限制的。那么看一下第二种</p>
</li>
<li><p>DFS+Trie：字典树的好处在于，如果我们有很多单词的前缀都一样而且特别长，字典树可以帮我们在board里面只寻找一次。</p>
<p>首先要知道如何构建字典树。</p>
<ul>
<li>字典树首先是一个有很多level的树，且每个level的branch的数量都是26（对于单词来说）。</li>
<li>字典树需要具备的方法是插入单词和查找单词。</li>
<li>字典树中每一个节点需要是一个dict 且 需要具备的性质是知道自己是否为一个单词。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Build Trie</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = collections.defaultdict(TrieNode)</span><br><span class="line">        self.isword = <span class="literal">False</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        </span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            start = start.children[w]</span><br><span class="line">        </span><br><span class="line">        start.isword = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        start = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            start = start.children.get(w)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> start:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start.isword</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findWords</span>(<span class="params">self, board, words</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        trie = Trie()</span><br><span class="line">        node = trie.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            trie.insert(w)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                self.dfs(board, i, j, node, <span class="string">&quot;&quot;</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, board, i, j, node, path, ans</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node.isword:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            node.isword = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        tmp = board[i][j]</span><br><span class="line"></span><br><span class="line">        node = node.children.get(tmp)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        board[i][j] = <span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line">        self.dfs(board, i+<span class="number">1</span>, j, node, path+tmp, ans)</span><br><span class="line">        self.dfs(board, i<span class="number">-1</span>, j, node, path+tmp, ans)</span><br><span class="line">        self.dfs(board, i, j+<span class="number">1</span>, node, path+tmp, ans)</span><br><span class="line">        self.dfs(board, i, j<span class="number">-1</span>, node, path+tmp, ans)</span><br><span class="line"></span><br><span class="line">        board[i][j] = tmp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0629-Leetcode62-Unique-Paths"><a href="#0629-Leetcode62-Unique-Paths" class="headerlink" title="0629 - Leetcode62 - Unique Paths"></a>0629 - Leetcode62 - Unique Paths</h1><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
</blockquote>
<p>解题思路：</p>
<p>老动态规划题了，很直接的想法，因为一个点只能由它上面一个点或者左边的点到达，那么我们定义dp表示到每个点一共有几条路径。</p>
<ul>
<li>定义动态规划矩阵：dp[i][j] 表示到达点 (i,j) 有几条unique的路径</li>
<li>状态转移方程： dp[i][j] = dp[i-1][j] +  dp[i][j-1]</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m) ]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode63-Unique-Paths-II"><a href="#补充-Leetcode63-Unique-Paths-II" class="headerlink" title="补充 - Leetcode63 - Unique Paths II"></a>补充 - Leetcode63 - Unique Paths II</h1><blockquote>
<p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
</blockquote>
<p>解题思路：</p>
<p>考虑障碍，有障碍的地方就设为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type obstacleGrid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> * (<span class="number">1</span> - obstacleGrid[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] * (<span class="number">1</span> - obstacleGrid[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] * (<span class="number">1</span> - obstacleGrid[<span class="number">0</span>][j])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]) * (<span class="number">1</span> - obstacleGrid[i][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="0628-Leetcode322-Reconstruct-Itenerary"><a href="#0628-Leetcode322-Reconstruct-Itenerary" class="headerlink" title="0628 - Leetcode322 - Reconstruct Itenerary"></a>0628 - Leetcode322 - Reconstruct Itenerary</h1><blockquote>
<p>Given a list of airline tickets represented by pairs of departure and arrival airports <code>[from, to]</code>, reconstruct the itinerary in order. All of the tickets belong to a man who departs from <code>JFK</code>. Thus, the itinerary must begin with <code>JFK</code>.</p>
<p><strong>Note:</strong></p>
<ol>
<li>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li>
<li>All airports are represented by three capital letters (IATA code).</li>
<li>You may assume all tickets form at least one valid itinerary.</li>
<li>One must use all the tickets once and only once.</li>
</ol>
<p><strong>Example 1:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span><br><span class="line">Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路</p>
<p>DFS，试探走路。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findItinerary</span>(<span class="params">self, tickets</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type tickets: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        paths = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        tickets.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> d, a <span class="keyword">in</span> tickets:</span><br><span class="line">            paths[d].append(a)</span><br><span class="line">            </span><br><span class="line">        self.dfs(<span class="string">&#x27;JFK&#x27;</span>, res, paths)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, d, res, paths</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># res.append(d)</span></span><br><span class="line">        arrivals = paths[d]</span><br><span class="line">        <span class="keyword">while</span> arrivals:</span><br><span class="line">            self.dfs(arrivals.pop(), res, paths)</span><br><span class="line">            </span><br><span class="line">        res.append(d)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h1 id="0627-Leetcode279-Perfect-squares"><a href="#0627-Leetcode279-Perfect-squares" class="headerlink" title="0627 - Leetcode279 - Perfect squares"></a>0627 - Leetcode279 - Perfect squares</h1><blockquote>
<p>Given a positive integer <em>n</em>, find the least number of perfect square numbers (for example, <code>1, 4, 9, 16, ...</code>) which sum to <em>n</em>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n &#x3D; 12</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 12 &#x3D; 4 + 4 + 4.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 13 = 4 + 9.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>动态规划。首先想到的就是动态规划，因为这道题和换零钱那道题太像了。但是做题的时候我不太能想起来换钱那道题是怎么做的了，就只记得换钱那道题考虑的是每一次，我这个1/2/5元的面值要不要参与其中。</p>
<p>所以这个题也差不多，刚开始的时候我想到的dp[i]是拥有i个square number的时候，可能组成的和的个数，这么一想的话，就有点像dfs了。所以我又换了个角度想了一下，dp[i]定义为：当和为i的时候，使用的最少的sqaure number有几个。</p>
<ul>
<li>dp矩阵的含义：当和为i的时候，使用的最少的sqaure number有几个</li>
<li>状态转移方程： dp[i] = min(dp[i], dp[i-square_number] + 1)。状态转移方程这里说的是，我们dp[i]使用的square number的个数可以由 dp[i - square number]使用的个数 + 1得到。</li>
<li>我一开始是循环整数将所有可能的（平方小于等于n）的数都找了一遍，然后存储起来，但是这样的话时间复杂度超过了。所以这里直接用 <code>range(1, int(n**0.5)+1)</code>来代替。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*(n+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>([dp[i - k**<span class="number">2</span>] + <span class="number">1</span> <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">int</span>(n**<span class="number">0.5</span>)+<span class="number">1</span>)])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>DFS</p>
<p>DFS 的思路也很好想到，就是你冲着一个数字一直选，直到达到想要的和n，然后返回这条路径用了几个square number，如果达到的和超过了n那么这条路径放弃，最后选出最短路径。</p>
</li>
</ol>
<h1 id="0626-Leetcode127-Sum-Root-to-Leaf-Number"><a href="#0626-Leetcode127-Sum-Root-to-Leaf-Number" class="headerlink" title="0626 - Leetcode127 - Sum Root to Leaf Number"></a>0626 - Leetcode127 - Sum Root to Leaf Number</h1><blockquote>
<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum &#x3D; 12 + 13 &#x3D; 25.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,9,0,5,1]</span><br><span class="line"><span class="code">    4</span></span><br><span class="line"><span class="code">   / \</span></span><br><span class="line"><span class="code">  9   0</span></span><br><span class="line"><span class="code"> / \</span></span><br><span class="line"><span class="code">5   1</span></span><br><span class="line"><span class="code">Output: 1026</span></span><br><span class="line"><span class="code">Explanation:</span></span><br><span class="line"><span class="code">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span></span><br><span class="line"><span class="code">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span></span><br><span class="line"><span class="code">The root-to-leaf path 4-&gt;0 represents the number 40.</span></span><br><span class="line"><span class="code">Therefore, sum = 495 + 491 + 40 = 1026.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>Recursive：</p>
<p>我是用recursive写的，主要思路是尝试找到每一个leaf. 如果一个节点的左右子节点都是none，那么这个节点就是leaf， 遇到了leaf之后，我们才能把它加到总结果上面。可以有两个方案，一个是将这些root-leaf的数字保存在list里面，然后最后返回list的和，另一个是直接用累加来记录。</p>
<p><strong>需要注意的是</strong> 在做累加的时候，累加的参量一定是self.ans内部的变化量，不然再没有返回值的情况下，普通的变量是不会变化的。但是如果是都放在list里面，这个是可以的，可以将他们都保存起来，list在递归的过程中是一直变化的。这里的例子是按照path写的，因为可以提供更多的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        ans = []</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        self.dfs(root, count, ans)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(ans)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, root, count</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line">            ans.append(count)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line">            self.dfs(root.left, count, ans)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> root.left:</span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line">            self.dfs(root.right, count, ans)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">                    </span><br><span class="line">            count = <span class="number">10</span>*count + root.val</span><br><span class="line"></span><br><span class="line">            self.dfs(root.left, count, ans)</span><br><span class="line">            self.dfs(root.right, count, ans)</span><br></pre></td></tr></table></figure>
</li>
<li><p>dfs+stack</p>
<p>这个思路是stack的顺序，然后改变每一个node的值为：到该点为止的累加值。</p>
<p>首先需要拿出root，然后放入stack中的数字是root的左右子节点，但是左右子节点对应的val的值分别存入的是 root.val*10 + root.right.val 和 root.val*10 + root.left.val,这样一直往stack里面放数字，如果左右子节点均为空，那么就用ans + 该点的val，如果左右子节点其中有一个为空，也不用管，直接return就可以。循环一直持续，直到stack中没有存储值。</p>
<p>（并没有改变树本身，而是在存在stack里面之后才改变了每个节点对应的value的值。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        stack = [(root, root.val)]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line"></span><br><span class="line">            root, val = stack.pop()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line"></span><br><span class="line">                res += val</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                stack.append((root.right, val*<span class="number">10</span> + root.right.val))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                stack.append((root.left, val*<span class="number">10</span> + root.left.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0625-Leetcode287-Find-the-Duplicate-Number"><a href="#0625-Leetcode287-Find-the-Duplicate-Number" class="headerlink" title="0625 - Leetcode287 - Find the Duplicate Number"></a>0625 - Leetcode287 - Find the Duplicate Number</h1><blockquote>
<p>Given an array <em>nums</em> containing <em>n</em> + 1 integers where each integer is between 1 and <em>n</em> (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>我一开始想的都太肤浅了，这道题的要求是时间复杂度不大于 $O(n^2)$, 空间复杂度为$O(1)$。 如果你普通得把见过一次的数字存在一个list里面，然后遍历整个序列的话，时间复杂度没超标但是空间复杂度超标了。</p>
<p>还有一种方法是可以用set，将nums进行set处理，然后nums和set过的nums求和做差，然后再除以两个nums的长度差。这种算法不知道算不算改变原有的nums，但同样也可以pass。</p>
<p>然后就来看看根正苗红的做法，可以用binary search来做。这里值得注意的是，题目中提到的，我们的nums的长度为n+1而nums中的数字都处于[1, …, n]。我们利用二分法查找来看多出来的这个duplicate数字究竟在哪里。</p>
<ul>
<li>首先左右两端的端点定下来，然后寻找中间的数字。</li>
<li>之后查看nums中，小于等于中间这个数nums[mid]的数字个数，如果数字个数等于或者小于nums[mid], 这说明重复的数字出现在右侧，这时候更新left = mid + 1；否则的话更新right = mid。</li>
<li>这样我们的时间复杂度是 $O(nlogn)$, 空间复杂度是 $O(1)$</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findDuplicate</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        order = <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(order) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right)/<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> n &lt;= order[mid]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> count &gt; order[mid]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> order[left]</span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode142-Linked-List-Cycle-II"><a href="#补充-Leetcode142-Linked-List-Cycle-II" class="headerlink" title="补充 - Leetcode142 - Linked List Cycle II"></a>补充 - Leetcode142 - Linked List Cycle II</h1><blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p>
<p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p>
<p><strong>Note:</strong> Do not modify the linked list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ul>
<li>查看linked list里面有没有cycle就很直接，设两个pointer 一个一次走一步，一个一次走两步，看两个pointer会不会相遇，如果相遇，那么就说明有cycle，如果与一个pointer率先到达none，也就是最后的端点，那么这个linked list就是没有cycle</li>
<li>slow 和fast pointer相遇之后，要看一下这个cycle有多长，则固定fast不动，每次走一步slow，看走几步之后slow会和fast相遇，这时候得到了cycle中node的个数，也就是cycle的长度N</li>
<li>那就等于说，如果我们再设置两个pointer，一个比另一个多N步，那么他们会在某一个相遇，而相遇的位置就是cycle开始的位置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> slow.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># print(fast.val, slow.val)</span></span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                step = slow.<span class="built_in">next</span></span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">                p1 = head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">while</span> step != slow:</span><br><span class="line">                    step = step.<span class="built_in">next</span></span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                p2 = head</span><br><span class="line">                s = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                    <span class="keyword">if</span> p1 == p2:</span><br><span class="line">                        <span class="keyword">return</span> p1</span><br><span class="line">                    p1 = p1.<span class="built_in">next</span></span><br><span class="line">                    p2 = p2.<span class="built_in">next</span></span><br><span class="line">                    s += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> </span><br></pre></td></tr></table></figure>
<h1 id="0624-Leetcode96-Unique-Binary-Search-Trees"><a href="#0624-Leetcode96-Unique-Binary-Search-Trees" class="headerlink" title="0624 - Leetcode96 - Unique Binary Search Trees"></a>0624 - Leetcode96 - Unique Binary Search Trees</h1><blockquote>
<p>Given <em>n</em>, how many structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>?</p>
</blockquote>
<p>解题思路：</p>
<p>初见这道题，我觉得肯定是用一个动态的思想去做，所以想到了dfs（怎么觉得dfs和dp的想法差不多呢，还是我自己没搞明白）</p>
<p>一开始我是想对于一个给定的数列nums，我可以分别以其中的一个数nums[i]为root，又因为是binary search tree，所以这个数字左边的部分nums[:i] 和右边的部分 nums[i+1:] 分别就在root的左边和右边。那么动态的去想一想，以nums[i]为root的BST的个数就等于nums[:i]的BTS个数<strong>加上</strong>nums[i+1:] 的BTS的个数。</p>
<p>但是！这里的<strong>加上</strong> 是不对的，因为如果在nums = [1,2,3]，以2为root时，左边1有一种可能，右边三有一种可能，加起来就是两种可能，所以是不正确的。应该是<strong>乘上</strong>！！</p>
<p>好，那以nums[i]为root的BTS的个数就等于nums[:i]数列BTS的个数 乘以 nums[i+1:]数列BTS的个数，然后我们遍历nums中所有的i，再把这些加起来。</p>
<p>这样就可以用DFS去做了。但是，我们还可以进一步的改进它。需要注意的是，我们的数列已经是顺序排列了，所以说，其实在计算BTS的个数的时候，我们不需要去担心数列里的数字是多少。比如，[1,2,3]和[4,5,6]生成的BTS的数目是一样的。所以我们在做DFS的时候，就会产生很多重复计算。这时候，我们就想到用DP了。</p>
<p>如果需要使用动态规划的算法，那么我们的一维dp[i]矩阵表示的就是，当数列的长度为i的时候，它存在的BTS的数目。</p>
<ul>
<li>dp[i] - 当数列的长度为i的时候，它存在的BTS的数目</li>
<li>状态转移方程 - dp[i] = sum([dp[k] * dp[i-1-k] for k in range(i))</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">  </span><br><span class="line">  dp = [<span class="number">0</span>]*(n+<span class="number">1</span>)</span><br><span class="line">  </span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">#一边为空时，所选方案为1种</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(dp)):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">      dp[i] += dp[j] * dp[i<span class="number">-1</span>-j]</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># dfs  -&gt; TLE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.dfs(nums, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, nums, count</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        count = <span class="built_in">sum</span>([self.dfs(nums[:i], count) * self.dfs(nums[i+<span class="number">1</span>:], count) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode95-Unique-Binary-Search-Tree-II"><a href="#补充-Leetcode95-Unique-Binary-Search-Tree-II" class="headerlink" title="补充 - Leetcode95 - Unique Binary Search Tree II"></a>补充 - Leetcode95 - Unique Binary Search Tree II</h1><blockquote>
<p>Given an integer <code>n</code>, generate all structurally unique <strong>BST’s</strong> (binary search trees) that store values 1 … <em>n</em>.</p>
<p><strong>Example:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>依循着上道题我的DFS的思路，看看能不能接着搞。</p>
<h1 id="0623-Leetcod222-Count-Complete-Tree-Node"><a href="#0623-Leetcod222-Count-Complete-Tree-Node" class="headerlink" title="0623 - Leetcod222 - Count Complete Tree Node"></a>0623 - Leetcod222 - Count Complete Tree Node</h1><blockquote>
<p>Given a <strong>complete</strong> binary tree, count the number of nodes.</p>
<p><strong>Note:</strong></p>
<p><strong>Definition of a complete binary tree from <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees">Wikipedia</a>:</strong><br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
</blockquote>
<p>解题思路：</p>
<p>本来想用dfs做的，就计数遍历过的node。但没写出来。</p>
<p>只能用题目中给出的需要计算 tree的depth。</p>
<p>已知给定的是complete binary tree，那么一定是左子树都填满之后再填右子树，所以说左右子数的深度就很能说明问题。</p>
<p>如果左右子树的depth相同，那么左子树是满的，可能出现问题的只可能是右子树</p>
<p>如果左右子树的depth不同，那么右子树是满的，我们需要继续探索左子树看他究竟有几层。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        leftDepth = self.getDepth(root.left)</span><br><span class="line">        rightDepth = self.getDepth(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> leftDepth == rightDepth:</span><br><span class="line">          <span class="keyword">return</span> (<span class="number">2</span>**leftDepth) + self.countNodes(root.right)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> (<span class="number">2</span>**rightDepth) + self.countNodes(root.left)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDepth</span>(<span class="params">self, root</span>):</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + self.getDepth(root.left)</span><br><span class="line">          </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h1 id="0622-Leetcode137-Single-Number-II"><a href="#0622-Leetcode137-Single-Number-II" class="headerlink" title="0622 - Leetcode137 - Single Number II"></a>0622 - Leetcode137 - Single Number II</h1><blockquote>
<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>three</em> times except for one, which appears exactly once. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>直接解题：</p>
<p>我们已经知道，除了一位数字之外，其他的数字出现的次数都是三次，那么我们可以将这个list进行set处理，然后求和乘以三，再减去之前未作处理的list求和，之后再除以2就可以得到想要的数字。所以这是一行很简单的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">3</span>*<span class="built_in">sum</span>(<span class="built_in">set</span>(nums)) - <span class="built_in">sum</span>(nums))//<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算：</p>
<p>我们可以利用二进制将数字都转化，所有出现三次的数字，他们的二级制也是一样的，所以说，每一位的和除以3一定是可以整除的，除非有一个其他的数字出来插一脚。所以我们的做法也很明确了，就是遍历所有位，然后对每一位的数求和并处以3，保存余数。以后再将这个二进制数还原为十进制整数。</p>
<ul>
<li>这里的range从32中取值是因为整数最多为32位。最后一步说明当得到的数字是负数的时候，我们要用正数减去最大值得到负数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums:                </span><br><span class="line">                count += (j&gt;&gt;i) &amp; <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            ans = ans | (count%<span class="number">3</span>) &lt;&lt; i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">2</span>**<span class="number">32</span> <span class="keyword">if</span> ans&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span> == <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="补充-Leetcode136-Single-Number-I"><a href="#补充-Leetcode136-Single-Number-I" class="headerlink" title="补充 - Leetcode136 - Single Number I"></a>补充 - Leetcode136 - Single Number I</h1><blockquote>
<p>Given a <strong>non-empty</strong> array of integers, every element appears <em>twice</em> except for one. Find that single one.</p>
<p><strong>Note:</strong></p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>同样，这道题有很多解，第一个就是和之前一样，因为除了一个数字只出现一次之外，别的数字都出现两次，所以我们可以接着把这个list中的数字做set处理求和，然后乘以2再减去处理之前的list求和，就可以得到只出现一次的那个数值了。同样也可以看到一个数字的时候把它放进list中，如果再看见就把它从list用pop出来，最后list中剩下的那个数字就是我们要找的数值。</p>
<p>这里我们还是讲一下位运算。</p>
<p>如果两个数字相同，说明他们转化为二进制之后，每一位上的数字个数都是2，除了之前我们说的，可以将每一位求和除以出现的次数2，然后找余数之外。对于出现两次（偶数次）的数字，我们可以做xor处理，即两位相同返回0，不同返回1. 当我们对两个相同的数字 a 和数字 b做 异或运算的时候，如果两个数字相同，那么<code>a^b = 0</code>, 否则的话肯定有一位是1。那么当我们对list中所有的数字做异或运算的时候，最后得到的结果就是多出来的那个数字。 还有一个 <strong>0和任何数字做异或运算都等于他本身</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        xor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            xor ^= n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> xor</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode260-Single-Number-III"><a href="#补充-Leetcode260-Single-Number-III" class="headerlink" title="补充 - Leetcode260 - Single Number III"></a>补充 - Leetcode260 - Single Number III</h1><blockquote>
<p>Given an array of numbers <code>nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.</p>
<p><strong>Example:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,1,3,2,5]</span><br><span class="line">Output: [3,5]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>这一题和之前两个题不同之处在于，这里出现一次的数字不止一个了，而是两个，所以之前两个题用到的做set处理之后求和，然后再减去之前的list的和，这种方法就失效了。</p>
<p>我们还是来考虑位运算。</p>
<p>既然是位运算，那么我们还是来看一看xor运算能给我们带来什么。之前说过的是，如果两个数字相同，那么做了异或运算之后我们会得到0，对所有数字进行异或运算可以帮助我们得到唯一一个不同的数字。那既然我们现在有两个只出现一次的数字，就说明对所有数字做了异或运算之后，我们得到的是这两个数字异或运算后的结果。</p>
<p>这个结果也是很重要的，得到的结果至少有一位是1（即两个数字这这一位上是不同的）。那么我们要做的就是找到这一位pointer，然后将nums中的数字分为两个部分。一部分数字在pointer这一位都为0，另一部分数字再pointer这一位都为1，这样的话，这两个数字就会分别处在两个不同的部分。然后我们对每个部分分别作异或运算，就可以得到两个出现一次的数字了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nxor = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            nxor = nxor ^ n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> (nxor &gt;&gt; i) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                pointer = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># print(pointer)</span></span><br><span class="line">        nums1 = []</span><br><span class="line">        nums2 = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> (n &gt;&gt; pointer) &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                nums1.append(n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums2.append(n)</span><br><span class="line">        <span class="comment"># print(nums1, nums2)</span></span><br><span class="line">        n1 = <span class="number">0</span> </span><br><span class="line">        n2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums1:</span><br><span class="line">            n1 = n1^n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums2:</span><br><span class="line">            n2 = n2^n</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> [n1, n2]</span><br></pre></td></tr></table></figure>
<h1 id="0621-Leetcode174-Dungeon-Games"><a href="#0621-Leetcode174-Dungeon-Games" class="headerlink" title="0621 - Leetcode174 - Dungeon Games"></a><a name="lc174"/>0621 - Leetcode174 - Dungeon Games</h1><blockquote>
<p>The demons had captured the princess (<strong>P</strong>) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (<strong>K</strong>) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (<em>negative</em> integers) upon entering these rooms; other rooms are either empty (<em>0’s</em>) or contain magic orbs that increase the knight’s health (<em>positive</em> integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
</blockquote>
<p>解题思路：（开心，是我自己徒手写的动态规划算法鸭）</p>
<p>这道题就是标准的动态规划的题目了。捋一捋思路。</p>
<ul>
<li><p>涉及二维的，只能通过往右和往下两种路径到达终点的题目，肯定涉及走不同的路径，然后选取到该点的最小cost的类的问题，所以这类问题需要倒着推。</p>
</li>
<li><p>首先明确我们dp[i][j] 的意义，既然我们要求的是到达dungeon[i][j]的最小路径和，那么我们就将 dp[i][j] 表示为到达dungeon[i][j] 的最小cost和，而dungeon[i][j]就表示在[i][j]点的cost。</p>
</li>
<li><p>然后来找状态转移方程，我们到达[i][j]点至少消耗的体力值，等于我们在[i+1][j]点至少消耗的体力值 + 在 [i-1][j] 消耗/获得 的体力值，或者是等于[i][j+1]点至少消耗的体力值 + 在 [i][j+1] 消耗/获得的体力值，至于选择从哪条路径来，就看哪条路径需要的体力值最小。</p>
<p>所以我们的状态转移方程为</p>
<p><code>dp[i][j] = min(dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])</code></p>
</li>
<li><p>但有一点需要注意的是，如果 dungeon[i][j] 获得的体力值 大于下一步即将消耗的体力值，那么我们其实获得将要消耗的体力值+1就可以了，因为如果过大，在之前的减法中，就会出现负数。举个例子：如果在<code>dungeon[i+1][j]</code>我们将会获得10点体力值，而到达<code>dp[i][j]</code>至少需要4点体力值的话，那么我们到达<code>dp[i+1][j]</code>时，至少需要有 -6点体力值，这是不可能的，因为如果体力值小于0，王子就死了。所以这个时候，我们到达<code>dp[i+1][j]</code>至少需要5点体力值， 即<code>dp[i+1][j]- dundeon[i][j]&gt;= 1</code>，所以我们的<code>dp[i+1][j]-1 &gt;= dundeon[i][j]</code>, 所以上一步的 <code>dp[i][j] = min(dp[i+1][j] - dungeon[i][j], dp[i][j+1] - dungeon[i][j])</code> 换为：<code>dp[i][j] = min(dp[i+1][j] - min(dungeon[i][j], dp[i+1][j]-1), dp[i][j+1] - min(dungeon[i][j], dp[i][j+1] - 1))</code></p>
</li>
<li><p>Initial Condition:  dp右下角点的值，也就是营救公主所需要的生命力 = <code>1 - min(dungeon[M-1][N-1], 0)</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateMinimumHP</span>(<span class="params">self, dungeon</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type dungeon: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        M = <span class="built_in">len</span>(dungeon)</span><br><span class="line">        N = <span class="built_in">len</span>(dungeon[<span class="number">0</span>]) </span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(M)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(M<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> i == M<span class="number">-1</span> <span class="keyword">and</span> j == N<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> - <span class="built_in">min</span>(dungeon[M<span class="number">-1</span>][N<span class="number">-1</span>], <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">elif</span> i == M<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j+<span class="number">1</span>] - <span class="built_in">min</span>(dungeon[i][j], dp[i][j+<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">elif</span> j == N<span class="number">-1</span>:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j] - <span class="built_in">min</span>(dungeon[i][j], dp[i+<span class="number">1</span>][j] - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:                </span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i+<span class="number">1</span>][j] - <span class="built_in">min</span>(dungeon[i][j], dp[i+<span class="number">1</span>][j]<span class="number">-1</span>), dp[i][j+<span class="number">1</span>] - <span class="built_in">min</span>(dungeon[i][j], dp[i][j+<span class="number">1</span>] - <span class="number">1</span>))</span><br><span class="line">        <span class="comment"># print(dp)</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h1 id="0620-Leetcode60-Permuation-Sequence"><a href="#0620-Leetcode60-Permuation-Sequence" class="headerlink" title=" 0620 - Leetcode60 - Permuation Sequence"></a><a name="lc60"/> 0620 - Leetcode60 - Permuation Sequence</h1><blockquote>
<p>The set <code>[1,2,3,...,*n*]</code> contains a total of <em>n</em>! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the following sequence for <em>n</em> = 3:</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>Given <em>n</em> and <em>k</em>, return the <em>k</em>th permutation sequence.</p>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>暴力求解</p>
<p>这个方法的时间复杂度会比较高，可能会造成Limit Time exceeded的错误，但是这里想要指出的是permuation这类题的共性，所以在这里指出。</p>
<p>我们首先要知道的这个nums序列permutation变化的规律：</p>
<ul>
<li>两个极端的例子是第一个permutation是从小到大依次排列的组合，第二个则是从大到小依次排列的组合。也就是说当我们的序列中存在非递减序列的时候，还是有下一次permute的可能性的，而当我们的序列已经是一个非递增序列的时候，这个permuation的过程就可以结束了。</li>
<li>我们要找的下一次permute的序列和本次序列的关系就是：找到本次序列中的非递增序列，然后将这个非递增序列的前一位（nums[pointer]）和非递增序列中稍大于这一位数字（nums[change]）的两项进行交换，最后顺序排列 nums[pointer+1::]</li>
</ul>
<p>这种方法可以帮我们按照顺序求解出来所有的permutation，既然我们要找的是第k个permutation，那么就将此步骤重复k-1次（因为第一个permutation不计入）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span>(<span class="params">self, n, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums = <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># print(i, nums)</span></span><br><span class="line">            self.nextPermutation(nums)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">str</span>(k) <span class="keyword">for</span> k <span class="keyword">in</span> nums)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        </span><br><span class="line">        pointer = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pointer &gt; <span class="number">0</span>:            </span><br><span class="line">            <span class="keyword">if</span> nums[pointer - <span class="number">1</span>] &gt;= nums[pointer]:</span><br><span class="line">                pointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        pointer -= <span class="number">1</span>        </span><br><span class="line">        change = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> change &gt; pointer:            </span><br><span class="line">            <span class="keyword">if</span> nums[change] &gt; nums[pointer]:                </span><br><span class="line">                nums[change], nums[pointer] = nums[pointer], nums[change]</span><br><span class="line">                nums[pointer+<span class="number">1</span>::] = <span class="built_in">sorted</span>(nums[pointer+<span class="number">1</span>::])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            change -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>直接按照可能出现的序列个数利用mod进行查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="补充-Leetcode31-Next-Permutation"><a href="#补充-Leetcode31-Next-Permutation" class="headerlink" title=" 补充 - Leetcode31 - Next Permutation"></a><a name="lc31"/> 补充 - Leetcode31 - Next Permutation</h1><blockquote>
<p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be <strong><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;1,2,3<span class="code">` → `</span>1,3,2`</span><br><span class="line">&gt;<span class="code">`3,2,1`</span> → <span class="code">`1,2,3`</span></span><br><span class="line">&gt;<span class="code">`1,1,5`</span> → `1,5,1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>按照上面总结的permutation的规律就可以得到。需要注意的是，如果permutation已经是最后一个，即倒序排列时，需要返回的是正序的第一个序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        pointer = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pointer &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[pointer<span class="number">-1</span>] &gt;= nums[pointer]:</span><br><span class="line">                pointer -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> pointer == <span class="number">0</span>:</span><br><span class="line">            nums[<span class="number">0</span>::] = nums[::<span class="number">-1</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        pointer -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        change = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> change &gt; pointer:</span><br><span class="line">            <span class="keyword">if</span> nums[change] &gt; nums[pointer]:</span><br><span class="line">                nums[change], nums[pointer] = nums[pointer], nums[change]</span><br><span class="line">                nums[pointer+<span class="number">1</span>::] = <span class="built_in">sorted</span>(nums[pointer+<span class="number">1</span>::])</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            change -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="0619-Leetcode1044-Longest-Duplicate-Substring"><a href="#0619-Leetcode1044-Longest-Duplicate-Substring" class="headerlink" title=" 0619 - Leetcode1044 - Longest Duplicate Substring"></a><a name="lc1044"/> 0619 - Leetcode1044 - Longest Duplicate Substring</h1><blockquote>
<p>Given a string <code>S</code>, consider all <em>duplicated substrings</em>: (contiguous) substrings of S that occur 2 or more times. (The occurrences may overlap.)</p>
<p>Return <strong>any</strong> duplicated substring that has the longest possible length. (If <code>S</code> does not have a duplicated substring, the answer is <code>&quot;&quot;</code>.)</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;banana&quot;</span><br><span class="line">Output: &quot;ana&quot;</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;abcd&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>Rabin Carp + Binary Search</p>
<p>这题但凡是有一点的修改都会因为时间复杂度太高而无法通过。</p>
<p>首先来说说主要的想法Binary Search吧，个人感觉Rabin Carp只是为了降低搜索时候的时间复杂度而改变的。</p>
<p>这道题我们想要知道的是在string中重复出现的最长substring是什么。换个角度思考一下，如果我们给定了substring的长度，然后让你找这个长度下的substring有没有重复出现的，那么问题就会变得很清晰。这时候我们就可以用二分答案的方法来解决这个问题。假设最长substring的长度是m，那么substring长度为m-1， m-2，… 1的substring也会出现重复值。所以我们就可以用二分答案的方法来找到最长重复出现的substring。</p>
<ul>
<li>当 长度为length的substring找不到重复的时候，说明这个长度太长了，所以我们就更新右边的端点到mid</li>
<li>当长度为length的substring可以找到重复string的时候，说明我们能找到的substring可能比这个还长，所有我们就更新左边的端点到mid</li>
</ul>
<p>其次就是 Rabin Carp，这个是把每个长度的substring用一个数字来表示，然后放在一个set里面，放在string里面并且判断这个数字是否在string中是不行的，会超过时间，set的计算效率是高于list的。</p>
<p>这个将string转化为一个数字的过程就是Rabin Carp算法。我们需要知道的是string中总共可能出现的数字是多少，然后将每个可能出现的字符用一个数字来表示。这里，所有可能出现的字符就是26个字母，所以a-0, b-1, c-2, …这些表示出来就可以了。个人觉得将这个string转化为数字就好像26进制一样，每个不同组合的string都会有对应的数字，然后再将这些数字储存在set中。为了防止重复出现的数字，我们将26进制转化后的数字mod by一个很大的数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDupSubstring</span>(<span class="params">self, S</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        A = [<span class="built_in">ord</span>(c) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">for</span> c <span class="keyword">in</span> S]</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">testString</span>(<span class="params">length, MOD</span>):</span></span><br><span class="line">    </span><br><span class="line">            cur_hash = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(mid):</span><br><span class="line">                cur_hash = (cur_hash * <span class="number">26</span> + A[i]) % MOD</span><br><span class="line">                </span><br><span class="line">            string_set = &#123;cur_hash&#125;</span><br><span class="line">            max_pow = <span class="built_in">pow</span>(<span class="number">26</span>, length, MOD)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length, <span class="built_in">len</span>(S)):</span><br><span class="line">                <span class="comment"># print(string_set)</span></span><br><span class="line">                cur_hash = (cur_hash * <span class="number">26</span> - A[i - length]*max_pow + A[i]) % MOD</span><br><span class="line">                <span class="keyword">if</span> cur_hash <span class="keyword">in</span> string_set:</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span> - length</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    string_set.add(cur_hash)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>   </span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(S) - <span class="number">1</span></span><br><span class="line">        MOD = <span class="number">2</span>**<span class="number">63</span> - <span class="number">1</span></span><br><span class="line">        ans = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            pos = testString(mid, MOD)</span><br><span class="line">            <span class="comment"># print(pos)</span></span><br><span class="line">            <span class="keyword">if</span> pos != <span class="number">-1</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">                ans = S[pos:pos+mid]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Suffix Array + Longest Common Prefix</p>
<p>这个方法就很巧妙了，主要是找到这个string从头开始的substring，然后再将这个substring排序，之后找这些substring里面最长的前缀。</p>
<ul>
<li><p>首先需要提取字符串的所有suffix，也就是后缀。</p>
<p>为什么要取后缀呢？因为按照brute borce的思想，假设我们先确定了一个字符i的位置，我们会做的是，在i后面的每一个字符起，开始遍历，试图去找一下是否有重复substring。所以我们要先把suffix提取出来</p>
</li>
<li><p>然后按照suffix的字母顺序进行排序。其实这个步骤就是隐性的帮我们把有重复项的suffix排在了一起，我们要做的就是找current suffix和它之后的suffix有多长重复的prefix（也就是当拿出两个已排好序的相邻的suffix从头进行比较，看两者最长的重复substring是什么）。</p>
</li>
<li><p>找出的最长prefix就被称作是Longest Common Prefix，这样也是可以解决这个问题的。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0618-Leetcode275-H-index-II"><a href="#0618-Leetcode275-H-index-II" class="headerlink" title=" 0618 - Leetcode275 - H-index II"></a><a name="lc275"/> 0618 - Leetcode275 - H-index II</h1><blockquote>
<p> Given an array of citations <strong>sorted in ascending order</strong> (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/H-index">definition of h-index on Wikipedia</a>: “A scientist has index <em>h</em> if <em>h</em> of his/her <em>N</em> papers have <strong>at least</strong> <em>h</em> citations each, and the other <em>N − h</em> papers have <strong>no more than</strong> <em>h</em> citations each.”</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: citations &#x3D; [0,1,3,5,6]</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had </span><br><span class="line">             received 0, 1, 3, 5, 6 citations respectively. </span><br><span class="line">             Since the researcher has 3 papers with at least 3 citations each and the remaining </span><br><span class="line">             two with no more than 3 citations each, her h-index is 3.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>二分法查找：</p>
<p>首先明确目标：我们要找最小的能使 citations[i] &gt;= len(citations) - i 的值</p>
<p>因为这里的citations中的数字都被排序了，所以我们可以使用二分法。</p>
<ul>
<li><p>首先设置的是左右两边的pointer: left = 0, right = len(citations) - 1</p>
</li>
<li><p>设置循环条件：while left &lt; right </p>
</li>
<li><p>更新：left = mid + 1; right = mid </p>
<p>更新的条件是判断citations[mid] &gt;= len(citations) - mid</p>
<p>如果该条件成立，说明我们要找的点就在mid或是mid的左边(不一定mid这一点是最小的能满足这个条件的点)，所以这时我们更新right = mid </p>
<p>如果该条件不成立，即citations[mid] &lt; len(citations) - mid，说明我们要找的点一定在mid的右边，所有我们更新 left = mid + 1</p>
</li>
<li><p><strong>因为我们的循环条件是 while left &lt; right</strong> 所以当left == right的时候，并没有审核citations[left]这个值符不符合要求，所以我们在最后需要再加上判别条件</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(citations) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                   </span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(citations) - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right)/<span class="number">2</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> citations[mid] &gt;= <span class="built_in">len</span>(citations) - mid:</span><br><span class="line">                right = mid </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> citations[left] &gt;= <span class="built_in">len</span>(citations) - left:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(citations) - left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(citations) - (left+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Brute force：</p>
<p>设置pointer i从0开始，i代表的位置就是我们找到的最小的能使 citations[i] &gt;= len(citations) - i 的值。</p>
<ul>
<li>当 citations[i] &lt; len(citations) - i的时候，意味着，在i点被引用的次数小于从i开始的文章数目，需要将i往后移动一位。</li>
<li>当 citations[i] &gt;= len(citations) - i 的时候，意味着在i点，被引用的次数大于等于后面的文章数目了，所以此时我们已经找到了可以满足条件的i的位置，需要返回的是从i开始一共有几篇文章的数目，即len(citations) - i</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hIndex</span>(<span class="params">self, citations</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type citations: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(citations):</span><br><span class="line">            <span class="keyword">if</span> citations[i] &gt;= <span class="built_in">len</span>(citations) - i:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">len</span>(citations) - i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0617-Leetcode130-Surrounded-Regions"><a href="#0617-Leetcode130-Surrounded-Regions" class="headerlink" title=" 0617 - Leetcode130 - Surrounded Regions"></a><a name="lc130"/> 0617 - Leetcode130 - Surrounded Regions</h1><blockquote>
<p>Given a 2D board containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code> (<strong>the letter O</strong>), capture all regions surrounded by <code>&#39;X&#39;</code>.</p>
<p>A region is captured by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>
<p><strong>Explanation:</strong></p>
<p>Surrounded regions shouldn’t be on the border, which means that any <code>&#39;O&#39;</code> on the border of the board are not flipped to <code>&#39;X&#39;</code>. Any <code>&#39;O&#39;</code> that is not on the border and it is not connected to an <code>&#39;O&#39;</code> on the border will be flipped to <code>&#39;X&#39;</code>. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
</blockquote>
<p>解题思路：</p>
<p>这是一个联合分量的问题。</p>
<p>并不是说你网格中O的周围只要有一个是X，他就一定是X，，或者网格中的O周围有一个是O他就一定是O而是要看他边界的O是否相连接。</p>
<p>其实这里主要的一个思路是，如果网格中的O和边界上的O相连接，那么网格中的O就不用换成X，所以换个说法，我们在边界上寻找O，然后再看它和网格中间的哪些O相连，将这些O标记成新的量G，之后将所有没有被标记为G的O点，也就是不和外界相连的O点换成X。</p>
<p>用到的主要方法就是DFS，即我们寻找边界上的O，然后在他的上下左右方向寻找相连的O，将这些点标记为G。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, board</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: None Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(board) &lt;=<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">markG</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(board) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j]!=<span class="string">&#x27;O&#x27;</span>: <span class="keyword">return</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                board[i][j] = <span class="string">&#x27;G&#x27;</span></span><br><span class="line">                markG(i<span class="number">-1</span>, j)</span><br><span class="line">                markG(i+<span class="number">1</span>, j)</span><br><span class="line">                markG(i, j<span class="number">-1</span>)</span><br><span class="line">                markG(i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            markG(i, <span class="number">0</span>)</span><br><span class="line">            markG(i, <span class="built_in">len</span>(board[<span class="number">0</span>]) - <span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">            markG(<span class="number">0</span>, j)</span><br><span class="line">            markG(<span class="built_in">len</span>(board) - <span class="number">1</span>, j)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> board[i][j] == <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode200-Number-of-Islands"><a href="#补充-Leetcode200-Number-of-Islands" class="headerlink" title="补充 - Leetcode200 - Number of Islands"></a>补充 - Leetcode200 - Number of Islands</h1><blockquote>
<p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>这题和上一题是一样的，就是我们找到一个小岛之后，要把和它相连的部分都标记为“已遍历”，这里没有flag，就直接用一个别的符号来表示。然后当我们再次遇到这个点的时候就不会再遍历，造成重复。</p>
<p>唯一一点和上面一题不同的是，上面一题，只有和边界相接触的点才有可能被保存下来，但是这里只要是出现了1，我们就把他当做是一个岛。所以这里在写for循环的时候，需要遍历每一个 为 1 的点，并且我们遇到1的时候count+1。count累加不能写在dfs函数的里面，我们在把和之前1相邻的点标记为“已遍历”的时候就会不停地累加。这个累加要出现在我们发现一个 1 的时候。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">markG</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> i &gt;= <span class="built_in">len</span>(grid) <span class="keyword">or</span> j &lt; <span class="number">0</span> <span class="keyword">or</span> j&gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[i][j] != <span class="string">&#x27;1&#x27;</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">                markG(i+<span class="number">1</span>, j)</span><br><span class="line">                markG(i<span class="number">-1</span>, j)</span><br><span class="line">                markG(i, j+<span class="number">1</span>)</span><br><span class="line">                markG(i, j<span class="number">-1</span>)</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="comment"># print(grid)</span></span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    markG(i, j)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode547-Friend-Circles"><a href="#补充-Leetcode547-Friend-Circles" class="headerlink" title=" 补充 - Leetcode547 - Friend Circles"></a><a name="lc468"/> 补充 - Leetcode547 - Friend Circles</h1><blockquote>
<p>There are <strong>N</strong> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <strong>direct</strong> friend of B, and B is a <strong>direct</strong> friend of C, then A is an <strong>indirect</strong> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p>
<p>Given a <strong>N*N</strong> matrix <strong>M</strong> representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are <strong>direct</strong> friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, so they are in a friend circle. </span><br><span class="line">The 2nd student himself is in a friend circle. So return 2.</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends, </span><br><span class="line">so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<ol>
<li>N is in range [1,200].</li>
<li>M[i][i] = 1 for all students.</li>
<li>If M[i][j] = 1, then M[j][i] = 1.</li>
</ol>
</blockquote>
<p>解题思路:</p>
<p>同样是用DFS搜索方法，但是和之前小岛不同的是，这里的是否交朋友是无序的，所以我们不能光考虑上下左右的边界，需要考虑的是所在行的所有数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, M</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">markFriend</span>(<span class="params">i</span>):</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)):</span><br><span class="line">                <span class="keyword">if</span> M[i][k] == <span class="number">1</span>:</span><br><span class="line">                    M[i][k] = <span class="number">2</span></span><br><span class="line">                    M[k][i] = <span class="number">2</span></span><br><span class="line">                    markFriend(k)         </span><br><span class="line">                </span><br><span class="line">        count = <span class="number">0</span>     </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(M)):</span><br><span class="line">            <span class="keyword">if</span> M[i][i] == <span class="number">1</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                M[i][i] = <span class="number">2</span></span><br><span class="line">                markFriend(i)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<h1 id="0616-Leetcode468-Validate-IP-Address"><a href="#0616-Leetcode468-Validate-IP-Address" class="headerlink" title=" 0616 - Leetcode468 - Validate IP Address"></a><a name="lc468"/> 0616 - Leetcode468 - Validate IP Address</h1><blockquote>
<p>Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.</p>
<p><strong>IPv4</strong> addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (“.”), e.g.,<code>172.16.254.1</code>;</p>
<p>Besides, leading zeros in the IPv4 is invalid. For example, the address <code>172.16.254.01</code> is invalid.</p>
<p><strong>IPv6</strong> addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (“:”). For example, the address <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so <code>2001:db8:85a3:0:0:8A2E:0370:7334</code> is also a valid IPv6 address(Omit leading zeros and using upper cases).</p>
<p>However, we don’t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, <code>2001:0db8:85a3::8A2E:0370:7334</code> is an invalid IPv6 address.</p>
<p>Besides, extra leading zeros in the IPv6 is also invalid. For example, the address <code>02001:0db8:85a3:0000:0000:8a2e:0370:7334</code> is invalid.</p>
<p><strong>Note:</strong> You may assume there is no extra space or special characters in the input string.</p>
</blockquote>
<p>解题思路：</p>
<p>这个题看似简单，就是判断输入的字符串是IPv4还是IPv6，但实际太复杂了，这两种地址的条条框框太多了，一开始我是自己写的，后来test case实在无法通过，就参考了<a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-ip-address/discuss/95484/PythonJava-Easy-Understand-Solution">这里</a> 的写法。</p>
<p>我们就来分析一下：</p>
<ul>
<li>IPv4<ol>
<li>当用 ‘.’ 将字符串split开的时候，长度必须为4（说的是有四个分开的部分，三个 ‘.’）</li>
<li>每个split出来的字符串的都必须是数字，长度不能超过3，但是不能以0开头</li>
<li>每个split出来的字符串中的数字不能为-1（谁能想到test case里面还有-1）</li>
</ol>
</li>
<li>IPv6<ol>
<li>当用 ‘:’ 字符串split开的时候，长度必须是8</li>
<li>每个split出来的字符串都必须是16进制，长度不能超过4，可以以0开头</li>
<li>每个split出来的字符串中的数字不能为-1</li>
</ol>
</li>
<li><strong>最好用try except去做，不然其他的情况太多了，不能完全覆盖</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIPv4</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">    <span class="comment">#检查的是每个被 ‘.’ 隔离开的字符串</span></span><br><span class="line">    <span class="comment"># 1. str(int(s)) == s 检查字符串中的数字是否以0开头, 还可以避免-0的情况</span></span><br><span class="line">    <span class="comment"># 2. 0 &lt;= int(s) &lt;= 255 检查字符串中的数字是否在规定范围内</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">int</span>(s)) == s <span class="keyword">and</span> <span class="number">0</span> &lt;= <span class="built_in">int</span>(s) &lt;= <span class="number">255</span></span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIPv6</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">4</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">try</span>: </span><br><span class="line">      <span class="comment"># int(s, 16) 是将s由16进制转化为十进制的整数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">int</span>(s, <span class="number">16</span>) &gt;= <span class="number">0</span> <span class="keyword">and</span> s[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span></span><br><span class="line">    <span class="keyword">except</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validIPAddress</span>(<span class="params">self, IP</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type IP: str</span></span><br><span class="line"><span class="string">    :rtype: str</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> IP.count(<span class="string">&quot;.&quot;</span>) == <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">all</span>(self.isIPv4(i) <span class="keyword">for</span> i <span class="keyword">in</span> IP.split(<span class="string">&quot;.&quot;</span>)): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IPv4&quot;</span></span><br><span class="line">    <span class="keyword">if</span> IP.count(<span class="string">&quot;:&quot;</span>) == <span class="number">7</span> <span class="keyword">and</span> <span class="built_in">all</span>(self.isIPv6(i) <span class="keyword">for</span> i <span class="keyword">in</span> IP.split(<span class="string">&quot;:&quot;</span>)): </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;IPv6&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="0615-Leetcode700-Search-in-a-binary-tree"><a href="#0615-Leetcode700-Search-in-a-binary-tree" class="headerlink" title=" 0615 - Leetcode700 - Search in a binary tree"></a><a name="lc700"/> 0615 - Leetcode700 - Search in a binary tree</h1><blockquote>
<p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node’s value equals the given value. Return the subtree rooted with that node. If such node doesn’t exist, you should return NULL.</p>
</blockquote>
<p>解题思路：</p>
<p>binary search tree</p>
<p>这里对于每个节点的左右进行搜索.因为binary search tree左右两边的node都是有大小顺序的，所以比较好排查，若果节点的val等于要找的value的值，那么就返回这个节点（所代表的tree），否则就一直往下找。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">if</span> val&gt;root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> val&lt;root.val:</span><br><span class="line">                root = root.left</span><br></pre></td></tr></table></figure>
<h1 id="0614-Leetcode787-Cheapest-Flights-within-K-stops"><a href="#0614-Leetcode787-Cheapest-Flights-within-K-stops" class="headerlink" title=" 0614 - Leetcode787 - Cheapest Flights within K stops."></a><a name="lc787"/> 0614 - Leetcode787 - Cheapest Flights within K stops.</h1><blockquote>
<p>There are <code>n</code> cities connected by <code>m</code> flights. Each flight starts from city <code>u</code> and arrives at <code>v</code> with a price <code>w</code>.</p>
<p>Now given all the cities and flights, together with starting city <code>src</code> and the destination <code>dst</code>, your task is to find the cheapest price from <code>src</code> to <code>dst</code> with up to <code>k</code> stops. If there is no such route, output <code>-1</code>.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: </span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 1</span><br><span class="line">Output: 200</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li>动态规划：</li>
</ol>
<p>这题我一开始是想用动态规划来写的，但是这个dp矩阵我不知道怎么写。因为和之前的dp不同的是，图是无序的，所以无法用每个node的值来做横纵坐标，也就是说如果用城市的编号来写dp，然后每多走一步我们就滚动加上次的dp，是没法做的。</p>
<p>因此我琢磨了一下这道题对应的动态规划问题，也就是Bellman-ford’s方法，然后现在大概明白怎么进行了。</p>
<p>首先我们构建一个dp矩阵, dp[k][v] 代表在最多走k步的情况下，从起始点到点v的最短路程距离是多少。所以其实最终得到的dp矩阵可以告诉我们从src到每一个点的（最多走k步时）的路程距离，但最后返回的时候，我们只需要返回v = dst的值。</p>
<p>来看看动态规划问题：</p>
<ul>
<li>子问题：当最多可以走k步时，从src到v的最短距离为：最多走k-1步，从src到v的最短距离 以及 最多走k-1步，src到u的最短距离+u到v的距离 当中的最小值。</li>
<li>状态转移方程： dp[k][v] = min(dp[k-1][v], dp[k-1][u]+cost[u][v])</li>
</ul>
<p>我们来看看图：</p>
<p><img src="/images/Note%20Jun%206,%202020-2274380.jpeg" alt="Note Jun 6, 2020-2274380"></p>
<p>dp矩阵图：</p>
<p><img src="/images/Note%20Jun%206,%202020-2.jpeg" alt="Note Jun 6, 2020-2"></p>
<ul>
<li>首先，规定我们的参数：src = 0, dst = 2, k = 1, n = 5, edge的长度如图所示。</li>
<li>明确几点common sense：<ol>
<li>因为我们的出发点是src，所以当v=src（终点等于起点）的时候，dp[k][src] = 0. 翻译一下，也就是说，当我们最多走k步的时候, src到自己的最短距离都是0</li>
<li>因为我们考虑的情况是，当你走的步数变多，到达dst的距离可能会缩短，所以说，k-1步的距离肯定要大于等于k步的距离，即dp[k-1][dst] &gt;= dp[k][dst]，所以dp[k][dst]的初始值就是dp[k-1][dst]。dp[k][dst] = dp[k-1][dst]表示多给出来我们走的那一步机会我们不用。</li>
<li>如果要更新src到dst的距离，我们关心的是能到dst的点的上一步的最短距离。那这个例子来说，如果我们的dst为2，在更新的时候我们只关注src到0，1，3点的最短距离，因为只有这三个点可以到达2.所以我们在从edges这个list构建cost函数的时候也需要注意。如果不想考虑这些内容，那么没有连接的两个node之前的距离可以记做 $\infty$</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span>(<span class="params">self, n, flights, src, dst, K</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type flights: List[List[int]]</span></span><br><span class="line"><span class="string">        :type src: int</span></span><br><span class="line"><span class="string">        :type dst: int</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cost = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cost[i] = &#123;&#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> flights:</span><br><span class="line">            cost[f[<span class="number">1</span>]][f[<span class="number">0</span>]] = f[<span class="number">2</span>]</span><br><span class="line">            </span><br><span class="line">        dp = [[<span class="built_in">float</span>(<span class="string">&#x27;Inf&#x27;</span>)]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">2</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][src] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> j == src:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">                    <span class="keyword">for</span> u <span class="keyword">in</span> cost[j]:</span><br><span class="line">                        <span class="comment"># print(dp[i-1][u]+cost[j][u], dp[i-1][j])</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][u]+cost[j][u], dp[i][j])</span><br><span class="line">                        <span class="comment"># print(dp[i][j])</span></span><br><span class="line">                        </span><br><span class="line">        <span class="keyword">if</span> dp[K+<span class="number">1</span>][dst] == <span class="built_in">float</span>(<span class="string">&#x27;Inf&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[K+<span class="number">1</span>][dst]</span><br></pre></td></tr></table></figure>
<ol>
<li>深度优先搜索</li>
</ol>
<h1 id="0613-Leetcode368-Largest-Divisible-Subset"><a href="#0613-Leetcode368-Largest-Divisible-Subset" class="headerlink" title="0613 - Leetcode368 - Largest Divisible Subset"></a><a name="lc368"/>0613 - Leetcode368 - Largest Divisible Subset</h1><blockquote>
<p>Given a set of <strong>distinct</strong> positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:</p>
<p>Si % Sj = 0 or Sj % Si = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
</blockquote>
<p>解题思路：</p>
<p>排序之后 + 动态规划</p>
<ul>
<li><p>排序的原因：假设 $a&lt;b&lt;c$ ， 如果 $b\%a = 0$ 且 $c\%b = 0$, 那么我们就不用计算 $c \% a = 0$, 而且在排序之后不会出现 被除数比除数大的情况。</p>
</li>
<li><p>动态规划子问题：假设我们用sol[k]来表示，输入数列中nums中的第l个数字对应的最长divisible序列。那么对于第j个数字，sol[j]的序列将会是 sol[i] + nums[j], where nums[j]%nums[i] == 0.</p>
</li>
<li><p>状态转移方程：sol[j] = sol[i] + nums[j]</p>
<p>注意这里需要有两个限定条件： 1. nums[j]%nums[i] == 0，这点是必须的，用来寻找nums[j]的可整除项；2. len(sol[j]) + 1 &gt; len(sol[i]) ，这个在判定当前sol[j]的序列的长度加上nums[i] 是否大于sol[j]来已经有的序列长度。</p>
<p><strong>万万不可</strong> 在找到了nums[j]%nums[i] == 0 就break啊，这样的话可能会错失更长的序列。比如，<code>[4, 8, 10, 240]</code> 这个就会输出 <code>[10, 240]</code>而不是<code>[4, 8, 240]</code>了</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">largestDivisibleSubset</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        sol = [[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[i] % nums[j] == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(sol[j]) + <span class="number">1</span> &gt; <span class="built_in">len</span>(sol[i]):</span><br><span class="line">                    sol[i] = sol[j] + [nums[i]]</span><br><span class="line">                    </span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(sol, key=<span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
<h1 id="补充-Leetcode300-Longest-Increasing-Subsequence"><a href="#补充-Leetcode300-Longest-Increasing-Subsequence" class="headerlink" title="补充 - Leetcode300 - Longest Increasing Subsequence"></a><a name="lc300"/>补充 - Leetcode300 - Longest Increasing Subsequence</h1><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p><strong>Example:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,9,2,5,3,7,101,18]</span><br><span class="line">Output: 4 </span><br><span class="line">Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ul>
<li>和上面lc368是一样的哦，只不过这里不涉及排序的问题，直接用动态规划就好了。</li>
<li>subsequence不意味着数字要连起来，所以和之前一样，也要遍历当前项之前的所有可能序列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        sol = [[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i] <span class="keyword">and</span> <span class="built_in">len</span>(sol[j])+<span class="number">1</span> &gt; <span class="built_in">len</span>(sol[i]):</span><br><span class="line">                    sol[i] = sol[j] + [nums[i]]</span><br><span class="line">                    </span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>([<span class="built_in">len</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> sol])</span><br></pre></td></tr></table></figure>
<p><a name="lc380"/> 0612 - Leetcode380 - Insert Delete GetRandom O(1)</p>
<blockquote>
<p>Design a data structure that supports all following operations in <em>average</em> <strong>O(1)</strong> time.</p>
<ol>
<li><code>insert(val)</code>: Inserts an item val to the set if not already present.</li>
<li><code>remove(val)</code>: Removes an item val from the set if present.</li>
<li><code>getRandom</code>: Returns a random element from current set of elements. Each element must have the <strong>same probability</strong> of being returned.</li>
</ol>
</blockquote>
<p>解题思路：</p>
<p>重点就是要用基本的数据结构去解决问题。这里用到了dictionary，可以用dictionary的key来存储值，value来存储位置，因为同一个数值只能出现一次，所以可以很好的运用dictionary.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.nums = []</span><br><span class="line">        self.pos = &#123;&#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> self.nums:</span><br><span class="line">            self.pos[val] = <span class="built_in">len</span>(self.nums) </span><br><span class="line">            self.nums.append(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, val</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.nums:</span><br><span class="line">            idx = self.pos[val]</span><br><span class="line">            self.nums[idx], self.nums[<span class="number">-1</span>] = self.nums[<span class="number">-1</span>], self.nums[idx]</span><br><span class="line">            self.pos[self.nums[idx]] = idx</span><br><span class="line">            <span class="keyword">del</span> self.pos[self.nums[<span class="number">-1</span>]]</span><br><span class="line">            </span><br><span class="line">            self.nums.pop()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        idx = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(self.nums)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.nums[idx]</span><br></pre></td></tr></table></figure>
<h1 id="0611-Leetcode75-Sorting-Colors-Medium"><a href="#0611-Leetcode75-Sorting-Colors-Medium" class="headerlink" title=" 0611 - Leetcode75 - Sorting Colors - Medium"></a><a name="lc75"/> 0611 - Leetcode75 - Sorting Colors - Medium</h1><blockquote>
<p>Given an array with <em>n</em> objects colored red, white or blue, sort them <strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/In-place_algorithm">in-place</a></strong> so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>
<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p><strong>Note:</strong> You are not suppose to use the library’s sort function for this problem.</p>
<p><strong>Example:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>因为存在三种颜色，所以用两次排序并且记录每个数字的个数是可以重新覆盖掉这个数组</p>
</li>
<li><p>存在三种颜色，我们可以用两个pointer分别从左右两端出发，左边的pointer卡在左侧1的位置，右边的pointer卡在右侧1的位置。还有一个pointer用来遍历。</p>
<p><strong>注意</strong>：控制循环的条件是k &lt;=j， 因为j移动的位置是已经排序过的，所以大于j的部分不需要考虑。考虑等于j是因为j所在的位置也还没有考虑，所以需要控制 k&lt;=j.</p>
<p>如果考虑 i &lt; j 会出现移动的pointer k一直往后移动，导致大于j的已经排序好的部分被打乱。</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: None Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= j:</span><br><span class="line">        <span class="keyword">if</span> nums[k] &lt; <span class="number">1</span>:</span><br><span class="line">            nums[k], nums[i] = nums[i], nums[k]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[k] == <span class="number">1</span>:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[k] &gt; <span class="number">1</span>:</span><br><span class="line">            nums[k], nums[j] = nums[j], nums[k]</span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="0610-Leetcode35-Search-Insert-Position-Easy"><a href="#0610-Leetcode35-Search-Insert-Position-Easy" class="headerlink" title=" 0610 - Leetcode35 - Search Insert Position - Easy"></a><a name="lc35"/> 0610 - Leetcode35 - Search Insert Position - Easy</h1><p><a target="_blank" rel="noopener" href="https://capchenxi.github.io/2020/01/09/Algorithm-Leetcode-array/#lc35">详解看这里</a></p>
<h1 id="0609-Leetcode392-Is-Subsequence"><a href="#0609-Leetcode392-Is-Subsequence" class="headerlink" title=" 0609 - Leetcode392 - Is Subsequence"></a><a name="lc392"/> 0609 - Leetcode392 - Is Subsequence</h1><blockquote>
<p>Given a string <strong>s</strong> and a string <strong>t</strong>, check if <strong>s</strong> is subsequence of <strong>t</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ace&quot;</code> is a subsequence of <code>&quot;abcde&quot;</code> while <code>&quot;aec&quot;</code> is not).</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s &#x3D; &quot;abc&quot;, t &#x3D; &quot;ahbgdc&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
</blockquote>
<p>重点：</p>
<ol>
<li>从利用两个pointer的角度，是一道比较简单的题，直接按顺序跑一遍就行。</li>
<li>从动态规划的角度，要考虑如何把这个问题想象成一个子问题。</li>
</ol>
<p>解题思路：</p>
<ol>
<li><p>Pointer.</p>
<p>在string和target里面分别设置两个pointer，然后遍历target里面的所有值，直到在string中都找到相应的值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">if</span> s[j] == s[i]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态规划</p>
<ol>
<li>动态规划矩阵: dp[i][j] 代表string[:i] 中是否包含target[:j]</li>
<li>子问题：dp[i][j] 是否为True取决于dp[i-1][j-1] 以及string[i]和target[j]</li>
<li>状态转移方程：<ul>
<li>当string[i]==target[j]时，若dp[i-1][j-1]为True，那么dp[i][j]也为True</li>
<li>当string[i]!=target[j]时，相当于此时string[i]是没用的，我们需要看dp[i-1][j]是否为True（表示当我们忽略掉string[i]的时候，string[:i-1] 中是否包含target[:j]）</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :type s: str</span></span><br><span class="line"><span class="string">    :type t: str</span></span><br><span class="line"><span class="string">    :rtype: bool</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    dp = [[<span class="literal">False</span>]*(<span class="built_in">len</span>(t)+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>)]</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)+<span class="number">1</span>):</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(t)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> s[row - <span class="number">1</span>] == t[col - <span class="number">1</span>]:</span><br><span class="line">                dp[row][col] = dp[row - <span class="number">1</span>][col - <span class="number">1</span>]                    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[row][col] = dp[row][col - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="补充-Leetcode115-Distinct-Subsequence-Hard"><a href="#补充-Leetcode115-Distinct-Subsequence-Hard" class="headerlink" title=" 补充 - Leetcode115 - Distinct Subsequence - Hard"></a><a name="lc115"/> 补充 - Leetcode115 - Distinct Subsequence - Hard</h1><blockquote>
<p>Given a string <strong>S</strong> and a string <strong>T</strong>, count the number of distinct subsequences of <strong>S</strong> which equals <strong>T</strong>.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, <code>&quot;ACE&quot;</code> is a subsequence of <code>&quot;ABCDE&quot;</code> while <code>&quot;AEC&quot;</code> is not).</p>
<p>It’s guaranteed the answer fits on a 32-bit signed integer.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: S &#x3D; &quot;rabbbit&quot;, T &#x3D; &quot;rabbit&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input: S = &quot;babgbag&quot;, T = &quot;bag&quot;</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">As shown below, there are 5 ways you can generate &quot;bag&quot; from S.</span><br><span class="line">(The caret symbol ^ means the chosen letters)</span><br><span class="line"></span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line"><span class="code">    ^^^</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<ol>
<li><p>动态规划：</p>
<ol>
<li>动态规划矩阵： dp[i][j]表示string[:i] 中否包含target[:j]的不同组合个数</li>
<li>子问题：dp[i][j] 代表的个数取决于dp[i-1][j-1] 以及string[i]和target[j]</li>
<li>状态转移方程：<ul>
<li>当string[i] == target[j] 时，dp[i][j] = dp[i-1][j-1] + dp[i][j-1] 表示当前两个字符相同的时候，现有组合数为dp[i-1][j-1] 加上dp[i][j-1] （考虑或者不考虑string[i]）</li>
<li>当string[i] ！= target[j]时，dp[i][j] =  dp[i][j-1]  表示只能跳过target[i] 看看 string[:i]能不能在target[:j-1]中出现了几次。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span>(<span class="params">self, s, t</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type t: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        M = <span class="built_in">len</span>(s)</span><br><span class="line">        N = <span class="built_in">len</span>(t)</span><br><span class="line">        </span><br><span class="line">        dp = [[<span class="number">0</span>]*(M+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]= [<span class="number">1</span>]*(M+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, M+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t[i<span class="number">-1</span>] == s[j<span class="number">-1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> dp[N][M]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0608-Leetcode231-Power-Of-Two-Easy"><a href="#0608-Leetcode231-Power-Of-Two-Easy" class="headerlink" title=" 0608 - Leetcode231-Power Of Two - Easy"></a><a name="lc231"/> 0608 - Leetcode231-Power Of Two - Easy</h1><blockquote>
<p>Given an integer, write a function to determine if it is a power of two.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: 1</span><br><span class="line">&gt;Output: true </span><br><span class="line">&gt;Explanation: 2^0 = 1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>重点：</p>
<ol>
<li>注意输入<strong>小于等于</strong>零的状况</li>
<li>注意在递归时的return标记</li>
</ol>
<p>解题思路：</p>
<ol>
<li><p>Iteration</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            n = n / <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Recursive</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.isPowerOfTwo(n/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0607-Leetcode518-Coin-Change-2"><a href="#0607-Leetcode518-Coin-Change-2" class="headerlink" title=" 0607 - Leetcode518 - Coin Change 2"></a><a name="lc518"/> 0607 - Leetcode518 - Coin Change 2</h1><blockquote>
<p>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: amount = 5, coins = [1, 2, 5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: there are four ways to make up the amount:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>重点：</p>
<ol>
<li>因为每个币值的coin的数量是无限的，所以我们在选择换零钱方案的时候，都可以选择使用或者不使用该币值的coin。</li>
<li>首先想到的方法是循环，但在循环的过程中也会产生重复的计算过程会超过time limit，所以提示我们可以用动态规划。</li>
</ol>
<p>解题思路：</p>
<ol>
<li><p>递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        <span class="keyword">return</span> self.countSol(amount, coins, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSol</span>(<span class="params">self, amount, coins, i</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> amount == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> amount &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="built_in">len</span>(coins) - <span class="number">1</span> <span class="keyword">and</span> amount &gt; <span class="number">0</span>:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> self.countSol(amount - coins[i], coins, i) + self.countSol(amount, coins, i + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态规划</p>
<p>动态规划的思路和刚才的递归的思路相似，但要如何构建DP空间呢？</p>
<p>之前我们所找到的状态转移方程是：某一(amount, coins)的方案数 = 考虑(coins[0])的状态数 + 不考虑该(coins[0]))的状态数。</p>
<p>假设一维动态矩阵dp[i], dp[i]表示：为了得到amount为i的结果，目前的coin有几种表达形式。</p>
<p>初始化： dp = [0]*(amount+1) 表示在没有coin的时候，生成i&gt;0每一种结果的方式都是0. 除了 dp[0] = 1.</p>
<p>第一次循环：考虑coin[0]， 在更新dp[i]之前，dp[i] 本身表示的就是生成该amount为i的方案中，不考虑coin[0] 时，我们有几种方法，而更新后的dp[i]还要加上dp[i-coin[0]]，表示拥有coin[0]之后，dp[i-coin[0]]个方法也可以被我们所用到了。</p>
<p>之后的循环都是一样的方法。</p>
<p>要注意的是，当在第j次循环下，如果 coin[j] &gt; i, 即coin[j]本身币值的大小，大于所需的amount值，那么新考虑的coin[j]对这些amount是没影响的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">self, amount, coins</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        dp = [<span class="number">0</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> coins[i] &lt;= j:</span><br><span class="line">                    dp[j] = dp[j] + dp[j - coins[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="补充-LeetCode322-Coin-Change"><a href="#补充-LeetCode322-Coin-Change" class="headerlink" title=" 补充 - LeetCode322 - Coin Change"></a><a name="lc322"/> 补充 - LeetCode322 - Coin Change</h1><blockquote>
<p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">Output: 3 </span><br><span class="line">Explanation: 11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: coins = [2], amount = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>和之前的一样，考虑动态规划问题，划分成subproblem，当前amount可得到的最小数量的coin和为（当前最小数量，dp[amount-coin[i]]+1）中的最小值。</p>
<p>重点：</p>
<ol>
<li>初始化的时候每一项初始化为 amount +1, 因为amount最多需要amount数量的coin</li>
<li>在判断能否生成该amount时只需判断dp[amount]是否仍为amount+1即可。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span>(<span class="params">self, coins, amount</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type coins: List[int]</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(coins)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= coins[i]:</span><br><span class="line">                    dp[j] = <span class="built_in">min</span>(dp[j - coins[i]] + <span class="number">1</span>, dp[j])</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> dp[amount] == (amount+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h1 id="0606-Leetcode1029-Two-City-Scheduling-Easy"><a href="#0606-Leetcode1029-Two-City-Scheduling-Easy" class="headerlink" title=" 0606 - Leetcode1029 - Two City Scheduling - Easy"></a><a name="lc1029"/> 0606 - Leetcode1029 - Two City Scheduling - Easy</h1><blockquote>
<p>There are <code>2N</code> people a company is planning to interview. The cost of flying the <code>i</code>-th person to city <code>A</code> is <code>costs[i][0]</code>, and the cost of flying the <code>i</code>-th person to city <code>B</code> is <code>costs[i][1]</code>.</p>
<p>Return the minimum cost to fly every person to a city such that exactly <code>N</code> people arrive in each city.</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: [[10,20],[30,200],[400,50],[30,20]]</span><br><span class="line">Output: 110</span><br><span class="line">Explanation: </span><br><span class="line">The first person goes to city A for a cost of 10.</span><br><span class="line">The second person goes to city A for a cost of 30.</span><br><span class="line">The third person goes to city B for a cost of 50.</span><br><span class="line">The fourth person goes to city B for a cost of 20.</span><br><span class="line"></span><br><span class="line">The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>解题思路：</p>
<p>1 -  遍历+排序</p>
<p>假设全部人被送往A，则我们的花费为 $\sum\limits_{i = 1}^{2N}cost[i][0]$。 </p>
<p>那我们的任务就变换为，从这A个人中挑选出来N个人，使他们的refund$ \sum\limits_{j=(1)}^{(N)}(- cost[i][0] + cost[i][1])$达到最大值。所以要做的就很简单，是把所有人的refund找出来，然后挑选前N个最大的。</p>
<p>（如果第$i$ 个人不去A了，改成去B，那么我们可以省去$cost[i][0] - cost[i][1]$这么多钱，省得越多越好）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoCitySchedCost</span>(<span class="params">self, costs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type costs: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        costA = <span class="built_in">sum</span>([c[<span class="number">0</span>] <span class="keyword">for</span> c <span class="keyword">in</span> costs])</span><br><span class="line">        save = [c[<span class="number">0</span>] - c[<span class="number">1</span>] <span class="keyword">for</span> c <span class="keyword">in</span> costs]</span><br><span class="line">        </span><br><span class="line">        save.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> costA - <span class="built_in">sum</span>(save[<span class="built_in">len</span>(costs)/<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
<p>2 - 动态规划</p>
<p>假设一个 $N \times N$ 的矩阵为DP矩阵，dp[i][j] 表示当i个人去A， j个人去B时的cost，所以dp矩阵的最后一项 dp[N][N] 代表N个人去A， N个人去B的cost。</p>
<ul>
<li>初始状态：第0行中的dp[0][j] 表示0个人去A，j个人去B；同样 dp[i][0]表示i个人去A， 0个人去B。</li>
<li>状态转移方程：</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/leetcode/" rel="tag"># leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/05/16/whatidid-%E6%8F%90%E5%8F%96CCL%E8%AF%AD%E6%96%99%E6%A3%80%E7%B4%A2%E5%BA%93%E6%A3%80%E7%B4%A2%E6%95%B0%E6%8D%AE/" rel="prev" title="whatidid | 提取CCL双语语料检索库检索数据">
                  <i class="fa fa-chevron-left"></i> whatidid | 提取CCL双语语料检索库检索数据
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/06/08/Algorithm-Sorting/" rel="next" title="Algorithm | Sorting">
                  Algorithm | Sorting <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chenxi</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  

</body>
</html>
